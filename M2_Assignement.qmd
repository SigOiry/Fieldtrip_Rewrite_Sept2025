---
title: "M2 Assignement"
author: "Simon Oiry"
editor_options: 
  chunk_output_type: console
---


This page demonstrates how to process the data just as the student should, using exactly the same dataset available to them. It can serve as a reference or correction for the student’s assignment.

# Study area & Methods

A field campaign was organized with Master’s students from the ACES and EBM programs. It took place in the seagrass meadow of Bourgneuf Bay, near the town of Barbâtre on Noirmoutier Island (@fig-Map_BB), on September 9th during low tide. The campaign had a dual purpose: to introduce students to the ecosystem and to collect a total of 60 sediment cores, sampling the top 15–20 cm of the substrate. Two sites were selected for coring. A historical analysis of the meadow over the past 40 years was carried out to identify areas with the most consistent and the most variable seagrass cover. Based on this analysis, site L was chosen in a zone that has shown strong variability in seagrass cover, while site H was located in an area with consistently high seagrass density over the same period.

At both sites, sampling locations were chosen to represent a range of seagrass percent cover. At each station, a photo-quadrat was taken using a 0.25 m² quadrat to estimate seagrass cover. Sediment cores were then collected using a 15 cm diameter PVC tube. Each core was cleaned to remove sediment, retaining only seagrass leaves and rhizomes as well as bivalves. The location of each sampling station was recorded using an Emlid Reach RS2+ GNSS receiver with RTK corrections from the Teria Network.

Back in the lab, each sample was sorted to separate leaves (above-ground biomass) from rhizomes (below-ground biomass). Both fractions were then dried at 60 °C for 48 hours, after which they were weighed for each sampling station.

In order to convert the biomass of the core to a biomass in m² A conversion factor has been applied to each biomass measurements : 

$$
\begin{align*}
Biomass_{m^{2}} &= \frac{100 \times 100}{Core_{Area}} \times Biomass_{Core} \\[6pt]
Core_{Area} &= \pi \times \left(\tfrac{15}{2}\right)^{2}
\end{align*}
$$

At the same time as sorting the above- and below-ground biomass, students also sorted living bivalves, recording the number of individuals of each species. The bivalve taxonomy was verified by a taxonomic expert from [Bio-Littoral](https://bio-littoral.fr).

To map the entire seagrass meadow, a Sentinel-2 image acquired on 6 September 2025, three days prior to the field campaign, was downloaded from the Copernicus Open Access Hub of the European Space Agency. The image was obtained at Level-2A processing, meaning that it had already been atmospherically corrected using the Sen2Cor algorithm and ortho-rectified to provide surface reflectance values in a cartographic geometry. 

```{r leafletmap}
#| fig-cap: Map of Bourgneuf Bay Sampling site
#| label: fig-Map_BB
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(leaflet)
library(sf)
library(leafem)
library(leaflet.extras2)
library(terra)

# folder structure: ./www/imgs/...
img_list <- list.files("data/imgs", recursive = TRUE, full.names = TRUE, pattern = "\\.jpg$") %>%
  tibble(path = .) %>%
  mutate(filename = basename(path),
         station  = substr(filename, 1, 4),
         url      = paste0(file.path("imgs", filename)))

mask <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>%
  st_transform(4326)


mask_S2 <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>% 
  st_buffer(-20)  %>%
  st_transform(4326)

img <- rast("data/S2_Meadow.tif") %>% 
  project("EPSG:4326") %>% 
  crop(mask_S2, mask = T) 
  
Points <- sf::st_read("data/shp/Core_Location/Points.shp", quiet = TRUE) %>%
  st_transform(4326) %>%
  left_join(img_list, by = c("Name" = "station")) %>%
  filter(!is.na(url)) %>% 
  mutate(Site = substr(Name,1,1))

pal <- colorFactor(
  palette = "Set2",   # you can use "Dark2", "Paired", "viridis", etc.
  domain  = Points$Site
)

# --- map ---
leaflet() %>%
  setView(lng = -2.176695, lat = 46.962474, zoom = 15) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery",
                   options = providerTileOptions(minZoom = 8, maxZoom = 20)) %>%
  addRasterRGB(img,r = 4, g = 3, b = 2,
               group = "Sentinel-2 image") %>% 
 addCircleMarkers(
    data = Points,
    radius = 4,
    color = ~pal(Site),      # outline color
    fillColor = ~pal(Site),  # fill color
    fillOpacity = 0.8,
    group = "Coring stations",
    popup = ~sprintf("<b>Sample:</b> %s<br><img src='%s' width='300'/>", Name, url)
  ) %>%
  addLayersControl(overlayGroups = c("Coring stations","Sentinel-2 image"),
                   options = layersControlOptions(collapsed = FALSE))

dir.create("docs/imgs")

copying <- file.copy(
    from = list.files("data/imgs", pattern = ".jpg",full.names = TRUE),
    to   = list.files("data/imgs", pattern = ".jpg",full.names = TRUE) %>% gsub("data","docs",.),
    recursive = TRUE,
    overwrite = TRUE
)

# htmlwidgets::saveWidget(plot_S2, file="maps/map_Bathy_Quiberon.html", selfcontained = F)

```

# Results 
## Mapping of the meadow

```{r Map_of_NDVI}
#| fig-cap: Map of NDVI of the meadow of Bourgneuf Bay
#| label: fig-Map_NDVI
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(leaflet)
library(sf)
library(leafem)
library(leaflet.extras2)
library(terra)

mask <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>%
  st_transform(4326)

mask_S2 <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>% 
  st_buffer(-20)  %>%
  st_transform(4326)

img <- rast("data/S2_Meadow.tif") %>% 
  project("EPSG:4326") %>% 
  crop(mask_S2, mask = T)

Points <- sf::st_read("data/shp/Core_Location/Points.shp", quiet = TRUE) %>%
  st_transform(4326) %>%
  # left_join(img_list, by = c("Name" = "station")) %>%
  # filter(!is.na(url)) %>% 
  mutate(Site = substr(Name,1,1))

pal <- colorFactor(
  palette = "Set2",   # you can use "Dark2", "Paired", "viridis", etc.
  domain  = Points$Site
)

NDVI <- ((img$S2_Meadow_8-1000)-(img$S2_Meadow_4-1000))/((img$S2_Meadow_8-1000)+(img$S2_Meadow_4-1000))

# create a color palette (viridis)
pal_ndvi <- colorNumeric(
  palette = viridis::viridis(256),
  domain = values(NDVI),
  na.color = "transparent"
)

# --- map ---
leaflet() %>%
  setView(lng = -2.176695, lat = 46.962474, zoom = 15) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery",
                   options = providerTileOptions(minZoom = 8, maxZoom = 20)) %>%
  addRasterImage(NDVI,
                 colors = pal_ndvi,
                 opacity = 0.8,
                 group = "NDVI") %>%
  addCircleMarkers(
    data = Points,
    radius = 4,
    color = ~pal(Site),      # outline color
    fillColor = ~pal(Site),  # fill color
    fillOpacity = 0.8,
    group = "Coring stations",
    popup = ~sprintf("<b>Sample:</b> %s<br>", Name)
  ) %>%
  # wire up click‐popup: show value with 2 decimals
  addImageQuery(
    # map    = .,
    x = NDVI[[1]],
    project = TRUE,
    layerId= "NDVI",
    type   = "mousemove",
    digits = 2,
    prefix = ""
  ) %>% 
  addLayersControl(
    overlayGroups = c("NDVI", "Coring stations"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    pal = pal_ndvi,
    values = values(NDVI),
    title = "NDVI",
    position = "bottomright"
  )

stat_meadow <- NDVI %>% 
  as_tibble() %>% 
  dplyr::filter(S2_Meadow_8 > 0) %>% 
  reframe(mean = mean(S2_Meadow_8),
         min = min(S2_Meadow_8),
         max = max(S2_Meadow_8))
```

@fig-Map_NDVI is showing the NDVI over the meadow. Overall the NDVI of non-water pixel is `r round(stat_meadow$mean,2)` with a maximum of `r round(stat_meadow$max,2)`. The average of NDVI over the meadow is particularly low in 2025, and is among the lowest values recorded in September since the start of the remote sensing acquisitions in the 1970's.

## Biomass vs NDVI

Only in Zone H, before coring, a hyperspectral signature of the sample
was taken using an ASD Fieldspec HandHeld 2. The instrument was
calibrated in the field for reflectance acquisition using a Spectralon
with a 99% reflective Lambertian surface (No radiance measurement has
been done). @fig-hyperspectral_m2 shows that a range of biomass was sampled during the field campaign, with H_04 having the least absorption in the red, indicating a low amount of chlorophyll-a, and H_08 showing the greatest absorption in the red part of the electromagnetic spectrum.

```{r Hyperspectral signature}
#| label: fig-hyperspectral_m2
#| fig-cap: Relationship between the NDVI and the above ground biomass of seagrasses sampled in site H. For each fit, the R-square and the Root mean square error are displayed.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| cache: false
#| out-width: "95%"

library(ggplot2)
library(ggiraph)
library(scales)
library(dplyr)
library(tidyverse)
library(plotly)

df_sp <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = T),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  mutate(ref_std = (ref_mean - min(ref_mean))/(max(ref_mean)-min(ref_mean))) %>% 
  dplyr::select(-sd) %>% 
  pivot_longer(c(ref_mean,ref_std), names_to = "Proc",values_to = "value") %>% 
  ungroup() %>% 
  mutate(Proc = case_when(Proc == "ref_mean" ~ "Raw",
                          T ~ "Standardised"))


# df_sp already created above

# make spectra a nicely ordered factor (optional)
df_sp <- df_sp %>%
  arrange(spectra, Wavelength) %>%
  mutate(spectra = factor(spectra, levels = sort(unique(spectra))))

p <- ggplot(
  df_sp,
  aes(x = Wavelength, y = value, color = spectra, group = spectra)
) +
  facet_wrap(~Proc, scales = "free")+
  # interactive line: tooltip shows spectra; data_id enables hover styling
  geom_line_interactive(
    aes(tooltip = paste0("Spectra: ", spectra),
        data_id  = spectra),
    linewidth = 0.9, alpha = 0.9, show.legend = F
  ) +
  scale_color_viridis_d(option = "viridis", end = 0.95) +
  scale_y_continuous(labels = label_percent(accuracy = 1)) +
  labs(
    x = "Wavelength (nm)",
    y = "Reflectance",
    color = "Spectra"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11),
    axis.title   = element_text(size = 13, face = "bold"),
    axis.text    = element_text(size = 11),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 7, height_svg = 5,
  options = list(
    # thicken the line you hover, fade others
    opts_hover(css = "stroke-width:2.5px;"),
    opts_hover_inv(css = "opacity:0.25;"),
    # nicer tooltip
    opts_tooltip(opacity = .95, css = "padding:6px; font-size:12px;")
  )
)
```

## Above ground biomass

From the hyperspectral signatures presented in @fig-hyperspectral_m2, the Normalized Difference Vegetation Index (NDVI) was computed for each sampling station. To evaluate how well this index can predict seagrass biomass, we examined its relationship with both above- and below-ground dry weight biomass. Several functional forms were tested, including linear, quadratic, log-linear, exponential, and power-law models, in order to capture potential nonlinearities in the NDVI–biomass relationship. For each model, the goodness of fit was assessed using the coefficient of determination (R²) and the root mean square error (RMSE).

```{r hyperspectral NDVI_ABiomass}
#| label: fig-hyperspectral_NDVI_ABiomass
#| fig-cap: Relationship between the NDVI of hyperspectral measurement and the dryweight of above ground biomass of seagrass sampled in zone H.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"
#| fig-height: 9
#| fig-width: 6

library(dplyr)
library(purrr)
library(broom)
library(ggplot2)
library(minpack.lm)
library(patchwork)

Core_Diameter <- 15 ### diameter of the core used for sampling (in cm)

core_area <- pi*((Core_Diameter/2)^2) #### Area of the core

correction_factor <- (100*100)/core_area #### Correction factor to convert the dry weight to g/m²

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A*correction_factor,
         B = B*correction_factor, 
         Area = substr(Station,1,1))

df_NDVI <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = TRUE),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  reframe(
    RED = ref_mean[which.min(abs(Wavelength - 670))],
    NIR = ref_mean[which.min(abs(Wavelength - 800))],
    NDVI = (NIR - RED) / (NIR + RED)
  ) %>% 
  left_join(dryweight, by = c("spectra" = "Station")) %>% 
  dplyr::select(-c(Area,NIR,RED))


#--- Data (ensure finite, drop NAs) ---
dat <- df_NDVI %>%
  select(NDVI, A) %>%
  filter(is.finite(NDVI), is.finite(A))

# --- helpers ---
metrics <- function(y, yhat) {
  sse <- sum((y - yhat)^2)
  sst <- sum((y - mean(y))^2)
  tibble(R2 = 1 - sse/sst, RMSE = sqrt(mean((y - yhat)^2)))
}
smear_factor <- function(resid) exp(0.5 * stats::var(resid))

# prediction grid
ndvi_seq <- tibble(NDVI = seq(min(dat$NDVI, na.rm = TRUE),
                              max(dat$NDVI, na.rm = TRUE), length.out = 200))

# ---- Model specs: fit, predict (original scale), label ----
specs <- list(
  linear = list(
    label = "Linear (A ~ NDVI)",
    fit = function(d) lm(A ~ NDVI, data = d),
    pred = function(fit, newd) tibble(A_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f + %.3f·NDVI", b[1], b[2])
    }
  ),
  quadratic = list(
    label = "Quadratic (A ~ NDVI + NDVI^2)",
    fit = function(d) lm(A ~ poly(NDVI, 2, raw = TRUE), data = d),
    pred = function(fit, newd) tibble(A_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f + %.3f·NDVI + %.3f·NDVI²", b[1], b[2], b[3])
    }
  ),
  log_linear = list(
    label = "Log-linear (A ~ log(NDVI))",
    fit = function(d) { d2 <- d %>% filter(NDVI > 0); lm(A ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      tibble(A_hat = as.numeric(predict(fit, newd2)))
    },
    eq  = function(fit) { b <- coef(fit); sprintf("A = %.3f + %.3f·log(NDVI)", b[1], b[2]) }
  ),
  exponential = list(
    label = "Exponential (A = a·e^{b·NDVI})",
    fit = function(d) { d2 <- d %>% filter(A > 0); lm(log(A) ~ NDVI, data = d2) },
    pred = function(fit, newd) {
      sf <- smear_factor(residuals(fit))
      tibble(A_hat = as.numeric(exp(predict(fit, newd)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f·e^{%.3f·NDVI}", exp(b[1]), b[2])
    }
  ),
  power = list(
    label = "Power (A = a·NDVI^b)",
    fit = function(d) { d2 <- d %>% filter(A > 0, NDVI > 0); lm(log(A) ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      sf <- smear_factor(residuals(fit))
      tibble(A_hat = as.numeric(exp(predict(fit, newd2)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f·NDVI^{%.3f}", exp(b[1]), b[2])
    }
  )
)

# ---- Bootstrap CI function (shared) ----
bootstrap_ci <- function(spec, d, newd, B = 400, conf = 0.95, seed = 123) {
  set.seed(seed)
  fit0  <- spec$fit(d)
  pred0 <- spec$pred(fit0, newd) %>% pull(A_hat)
  obs_hat <- spec$pred(fit0, d) %>% pull(A_hat)
  stats0  <- metrics(d$A, obs_hat)

  P <- matrix(NA_real_, nrow = nrow(newd), ncol = B)
  b <- 1
  while (b <= B) {
    idx <- sample(seq_len(nrow(d)), replace = TRUE)
    db  <- d[idx, , drop = FALSE]
    fb  <- try(spec$fit(db), silent = TRUE)
    if (inherits(fb, "try-error")) next
    pb  <- try(spec$pred(fb, newd) %>% pull(A_hat), silent = TRUE)
    if (inherits(pb, "try-error") || any(!is.finite(pb))) next
    P[, b] <- pb
    b <- b + 1
  }
  alpha <- (1 - conf) / 2
  lwr <- apply(P, 1, quantile, probs = alpha, na.rm = TRUE)
  upr <- apply(P, 1, quantile, probs = 1 - alpha, na.rm = TRUE)

  list(fit = fit0,
       grid = bind_cols(newd, tibble(A_hat = pred0, lwr = lwr, upr = upr)),
       stats = stats0)
}

# ---- Run the 5 models ----
results_list <- purrr::imap(specs, function(spec, key) {
  res <- bootstrap_ci(spec, dat, ndvi_seq, B = 400, conf = 0.95, seed = 42)
  list(
    key   = key,
    label = spec$label,
    fit   = res$fit,
    grid  = res$grid,
    eq    = specs[[key]]$eq(res$fit),
    stats = res$stats
  )
})

# ---- Build one plot per model ----
make_panel <- function(res) {
  eq_text  <- res$eq
  r2_text  <- sprintf("R² = %.3f | RMSE = %.2f", res$stats$R2, res$stats$RMSE)
  # lbl_text <- paste(eq_text, r2_text, sep = "\n")
  lbl_text = r2_text

  ggplot() +
    geom_point(data = dat, aes(NDVI, A), alpha = 0.8) +
    geom_ribbon(data = res$grid, aes(NDVI, ymin = lwr, ymax = upr), alpha = 0.2) +
    geom_line(data = res$grid, aes(NDVI, A_hat), linewidth = 1) +
    labs(title = res$label, x = "NDVI", y = "Above ground biomass (g/m²)") +
    annotate("text", x = 0.15, y = Inf, hjust = 0, vjust = 1.2,
             label = lbl_text, size = 3) +
    theme_minimal(base_size = 8)+
    theme(plot.title = element_text(size = 10))
}

panels <- lapply(results_list, make_panel)

# ---- Patchwork layout for 5 panels ----
wrap_plots(panels, ncol = 2)

```

$$ \begin{flalign*} \text{Linear: } & \quad Above = -19.952 + 185.677 \cdot \mathrm{NDVI} && \\[6pt] \textcolor{BurntOrange}{\text{Quadratic: }} & \quad Above = -0.643 + 83.650 \cdot \mathrm{NDVI} + 120.532 \cdot \mathrm{NDVI}^{2} && \\[6pt] \text{Log-linear: } & \quad Above = 121.622 + 67.956 \cdot \log(\mathrm{NDVI}) && \\[6pt] \text{Exponential: } & \quad Above = 9.784 \cdot e^{\,3.796 \cdot \mathrm{NDVI}} && \\[6pt] \text{Power law: } & \quad Above = 187.326 \cdot \mathrm{NDVI}^{1.457} && \end{flalign*} $$

The results, summarized in @fig-hyperspectral_NDVI_ABiomass, show that the quadratic model provided the best fits, with R² values around 0.657 and lowest RMSE compared to the other formulations, indicating that NDVI is a reliable predictor of above-ground seagrass biomass in this meadow.
 
## Below ground biomass

The relationships between NDVI and below-ground seagrass biomass were generally weaker than those observed for above-ground biomass. Across all functional forms tested (linear, quadratic, log-linear, exponential, and power law), the models explained less variance, with R² values ranging between 0.42 and 0.46 and RMSE around 21 g·m² (@fig-hyperspectral_NDVI_BBiomass). In comparison, the best above-ground models (quadratic and power law) reached R² values of about 0.65 and lower RMSE (~18 g·m²), highlighting a stronger predictive capacity of NDVI for the photosynthetic canopy than for the rhizome and root fraction. Among the below-ground fits, the quadratic and power law formulations again performed slightly better than the others, but improvements over the linear model were marginal. These results confirm that NDVI is more sensitive to variations in above-ground biomass, which directly affect canopy reflectance, whereas below-ground biomass shows only weak indirect correlations with spectral indices derived from hyperspectral measurements.

```{r hyperspectral NDVI_BBiomass}
#| label: fig-hyperspectral_NDVI_BBiomass
#| fig-cap: Relationship between the NDVI of hyperspectral measurement and the dryweight of below ground biomass of seagrass sampled in zone H.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"
#| fig-height: 9
#| fig-width: 6

library(dplyr)
library(purrr)
library(broom)
library(ggplot2)
library(minpack.lm)
library(patchwork)

Core_Diameter <- 15 ### diameter of the core used for sampling (in cm)

core_area <- pi*((Core_Diameter/2)^2) #### Area of the core

correction_factor <- (100*100)/core_area #### Correction factor to convert the dry weight to g/m²

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A*correction_factor,
         B = B*correction_factor, 
         Area = substr(Station,1,1))

df_NDVI <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = TRUE),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  reframe(
    RED = ref_mean[which.min(abs(Wavelength - 670))],
    NIR = ref_mean[which.min(abs(Wavelength - 800))],
    NDVI = (NIR - RED) / (NIR + RED)
  ) %>% 
  left_join(dryweight, by = c("spectra" = "Station")) %>% 
  dplyr::select(-c(Area,NIR,RED))


#--- Data (ensure finite, drop NAs) ---
dat <- df_NDVI %>%
  select(NDVI, B) %>%
  filter(is.finite(NDVI), is.finite(B)) %>% 
  rename(Below = "B")

# --- helpers ---
metrics <- function(y, yhat) {
  sse <- sum((y - yhat)^2)
  sst <- sum((y - mean(y))^2)
  tibble(R2 = 1 - sse/sst, RMSE = sqrt(mean((y - yhat)^2)))
}
smear_factor <- function(resid) exp(0.5 * stats::var(resid))

# prediction grid
ndvi_seq <- tibble(NDVI = seq(min(dat$NDVI, na.rm = TRUE),
                              max(dat$NDVI, na.rm = TRUE), length.out = 200))

# ---- Model specs: fit, predict (original scale), label ----
specs <- list(
  linear = list(
    label = "Linear (Below ~ NDVI)",
    fit = function(d) lm(Below ~ NDVI, data = d),
    pred = function(fit, newd) tibble(Below_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f + %.3f·NDVI", b[1], b[2])
    }
  ),
  quadratic = list(
    label = "Quadratic (Below ~ NDVI + NDVI^2)",
    fit = function(d) lm(Below ~ poly(NDVI, 2, raw = TRUE), data = d),
    pred = function(fit, newd) tibble(Below_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f + %.3f·NDVI + %.3f·NDVI²", b[1], b[2], b[3])
    }
  ),
  log_linear = list(
    label = "Log-linear (Below ~ log(NDVI))",
    fit = function(d) { d2 <- d %>% filter(NDVI > 0); lm(Below ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      tibble(Below_hat = as.numeric(predict(fit, newd2)))
    },
    eq  = function(fit) { b <- coef(fit); sprintf("Below = %.3f + %.3f·log(NDVI)", b[1], b[2]) }
  ),
  exponential = list(
    label = "Exponential (Below = a·e^{b·NDVI})",
    fit = function(d) { d2 <- d %>% filter(Below > 0); lm(log(Below) ~ NDVI, data = d2) },
    pred = function(fit, newd) {
      sf <- smear_factor(residuals(fit))
      tibble(Below_hat = as.numeric(exp(predict(fit, newd)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f·e^{%.3f·NDVI}", exp(b[1]), b[2])
    }
  ),
  power = list(
    label = "Power (Below = a·NDVI^b)",
    fit = function(d) { d2 <- d %>% filter(Below > 0, NDVI > 0); lm(log(Below) ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      sf <- smear_factor(residuals(fit))
      tibble(Below_hat = as.numeric(exp(predict(fit, newd2)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f·NDVI^{%.3f}", exp(b[1]), b[2])
    }
  )
)

# ---- Bootstrap CI function (shared) ----
bootstrap_ci <- function(spec, d, newd, B = 400, conf = 0.95, seed = 123) {
  set.seed(seed)
  fit0  <- spec$fit(d)
  pred0 <- spec$pred(fit0, newd) %>% pull(Below_hat)
  obs_hat <- spec$pred(fit0, d) %>% pull(Below_hat)
  stats0  <- metrics(d$Below, obs_hat)

  P <- matrix(NA_real_, nrow = nrow(newd), ncol = B)
  b <- 1
  while (b <= B) {
    idx <- sample(seq_len(nrow(d)), replace = TRUE)
    db  <- d[idx, , drop = FALSE]
    fb  <- try(spec$fit(db), silent = TRUE)
    if (inherits(fb, "try-error")) next
    pb  <- try(spec$pred(fb, newd) %>% pull(Below_hat), silent = TRUE)
    if (inherits(pb, "try-error") || any(!is.finite(pb))) next
    P[, b] <- pb
    b <- b + 1
  }
  alpha <- (1 - conf) / 2
  lwr <- apply(P, 1, quantile, probs = alpha, na.rm = TRUE)
  upr <- apply(P, 1, quantile, probs = 1 - alpha, na.rm = TRUE)

  list(fit = fit0,
       grid = bind_cols(newd, tibble(Below_hat = pred0, lwr = lwr, upr = upr)),
       stats = stats0)
}

# ---- Run the 5 models ----
results_list <- purrr::imap(specs, function(spec, key) {
  res <- bootstrap_ci(spec, dat, ndvi_seq, B = 400, conf = 0.95, seed = 42)
  list(
    key   = key,
    label = spec$label,
    fit   = res$fit,
    grid  = res$grid,
    eq    = specs[[key]]$eq(res$fit),
    stats = res$stats
  )
})

# ---- Build one plot per model ----
make_panel <- function(res) {
  eq_text  <- res$eq
  r2_text  <- sprintf("R² = %.3f | RMSE = %.2f", res$stats$R2, res$stats$RMSE)
  # lbl_text <- paste(eq_text, r2_text, sep = "\n")
  lbl_text = r2_text

  ggplot() +
    geom_point(data = dat, aes(NDVI, Below), alpha = 0.8) +
    geom_ribbon(data = res$grid, aes(NDVI, ymin = lwr, ymax = upr), alpha = 0.2) +
    geom_line(data = res$grid, aes(NDVI, Below_hat), linewidth = 1) +
    labs(title = res$label, x = "NDVI", y = "Below ground biomass (g/m²)") +
    annotate("text", x = 0.15, y = Inf, hjust = 0, vjust = 1.2,
             label = lbl_text, size = 3) +
    theme_minimal(base_size = 8)+
    theme(plot.title = element_text(size = 10))
}

panels <- lapply(results_list, make_panel)

# ---- Patchwork layout for 5 panels ----
wrap_plots(panels, ncol = 2)

```

$$
\begin{flalign*}
\text{Linear: } & \quad Below = -14.984 + 141.623 \cdot \mathrm{NDVI} && \\[6pt]
\textcolor{BurntOrange}{\text{Quadratic: }} & \quad Below = 4.189 + 84.580 \cdot \mathrm{NDVI} + 67.389 \cdot \mathrm{NDVI}^{2} && \\[6pt]
\text{Log-linear: } & \quad Below = 93.009 + 51.843 \cdot \log(\mathrm{NDVI}) && \\[6pt]
\text{Exponential: } & \quad Below = 7.937 \cdot e^{\,3.553 \cdot \mathrm{NDVI}} && \\[6pt]
\text{Power law: } & \quad Below = 124.392 \cdot \mathrm{NDVI}^{1.350} &&
\end{flalign*}
$$

For both the modeling of the above ground and the below ground biomass the **quadratic** relationship will be used for the rest of the analysis. 

## Mapping the biomass of seagrass across the meadow. 

Using the relationship found in @fig-hyperspectral_NDVI_ABiomass and @fig-hyperspectral_NDVI_BBiomass, the biomass of seagrass can be estimated from the NDVI at the scale of the entire mudflat. 

```{r mapping biomass from NDVI}
#| label: fig-Map_Biomass
#| fig-cap: Map of Above ground Biomass (Left) and Below ground biomass (right) of the seagrass *Zostera noltei* across the entire meadow
#| echo: false
#| eval: true
#| error: false
#| message: false
#| warning: false
#| cache: false
#| out-width: "95%"
#| fig-height: 9
#| fig-width: 4 

library(tidyverse)
library(leaflet)
library(leafem)          # addMouseCoordinates, addImageQuery
library(leaflet.extras2) # (optional extra controls)
library(sf)
library(terra)
library(raster)          # for leaflet raster compatibility
library(RColorBrewer)
library(leafsync) 

mask <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>%
  st_transform(4326)


mask_S2 <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>% 
  st_buffer(-20)  %>%
  st_transform(4326)

img <- rast("data/S2_Meadow.tif") %>% 
  project("EPSG:4326") %>% 
  crop(mask_S2, mask = T) 
  
NDVI <- ((img$S2_Meadow_8-1000)-(img$S2_Meadow_4-1000))/((img$S2_Meadow_8-1000)+(img$S2_Meadow_4-1000))

A_Biomass <- -0.643+83.65*NDVI + 120.532*(NDVI*NDVI)
values(A_Biomass)[values(A_Biomass)<0] <- 0

B_Biomass <- 4.189+84.58*NDVI + 67.389*(NDVI*NDVI)
values(B_Biomass)[values(B_Biomass)<0] <- 0

rA <- A_Biomass
rB <- B_Biomass

# palettes (different and non-viridis)
palA <- colorNumeric(
  palette = colorRampPalette(brewer.pal(9, "YlOrRd"))(256),
  domain  = raster::values(rA),
  na.color = "transparent"
)

palB <- colorNumeric(
  palette = colorRampPalette(brewer.pal(9, "PuBuGn"))(256),
  domain  = raster::values(rB),
  na.color = "transparent"
)

# a common view (center on mask)
ctr <- st_coordinates(st_centroid(st_union(mask))) %>% as.numeric()

# get min and max values for the rasters
rngA <- range(values(rA), na.rm = TRUE)
rngB <- range(values(rB), na.rm = TRUE)

# --- Map 1: Above-ground biomass (A) ---
mA <- leaflet(options = leafletOptions(minZoom = 8, preferCanvas = TRUE)) |>
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") |>
  setView(lng = ctr[1], lat = ctr[2], zoom = 14) |>
  addPolygons(data = mask, color = "#444", weight = 1, fill = FALSE, group = "Meadow") |>
  addRasterImage(rA, colors = palA, opacity = 0.85, group = "Above ground", project = TRUE) |>
  addLegend(
    pal = palA,
    values = values(rA),
    title = "Above-ground biomass (g·m²)",
    position = "bottomright",
    labFormat = labelFormat(digits = 0),
    # only show min and max
    bins = c(rngA[1], rngA[2])
  ) |>
  addImageQuery(rA[[1]], project = TRUE, layer = "Above ground", type = "mousemove", digits = 2, prefix = "") |>
  addScaleBar(position = "bottomleft")

# --- Map 2: Below-ground biomass (B) ---
rngB <- range(values(rB), na.rm = TRUE)

mB <- leaflet(options = leafletOptions(minZoom = 8, preferCanvas = TRUE)) |>
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") |>
  setView(lng = ctr[1], lat = ctr[2], zoom = 14) |>
  addPolygons(data = mask, color = "#444", weight = 1, fill = FALSE, group = "Meadow") |>
  addRasterImage(rB, colors = palB, opacity = 0.85, group = "Below ground", project = TRUE) |>
  addLegend(
    pal = palB,
    values = values(rB),
    title = "Below-ground biomass (g·m²)",
    position = "bottomright",
    labFormat = labelFormat(digits = 0),
    bins = c(rngB[1], rngB[2])  # only min & max
  ) |>
  addImageQuery(rB[[1]], project = TRUE, layer = "Below ground",type = "mousemove", digits = 2, prefix = "") |>
  addScaleBar(position = "bottomleft")


# --- Synchronized view (side-by-side) ---
leafsync::sync(mA, mB)


total_Abiomass = A_Biomass %>% 
  as_tibble() %>% 
  dplyr::filter(S2_Meadow_8 >0) %>% 
  reframe(sum = sum(S2_Meadow_8)* 0.1 * 0.001,
          mean = mean(S2_Meadow_8))

total_Bbiomass = B_Biomass %>% 
  as_tibble() %>% 
  dplyr::filter(S2_Meadow_8 >0) %>% 
  reframe(sum = sum(S2_Meadow_8)* 0.1 * 0.001,
          mean = mean(S2_Meadow_8))
```

@fig-Map_Biomass shows the spatial distribution of above- and below-ground biomass of Zostera noltei across the study site. In total, an estimated **`r round(total_Abiomass$sum,2)` tons** of leaves and **`r round(total_Bbiomass$sum,2)` tons** of roots are present within the study area. The average above ground biomass is `r round(total_Abiomass$mean,2)` g.m² while the below ground biomass averages at `r round(total_Bbiomass$mean,2)` g.m². 

# Bivalves

## Abundance

```{r Bivalve analysis}
#| label: fig-BivDensity_m2
#| fig-cap: Average density of each bivalve specie across all 60 cores (Left) and Percentage of core were each species were found (Right). 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(readxl)
library(patchwork)

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia plana","S. plana",Species),
         Species = gsub("Ruditapes derussatus","R. decu.", Species),
         Species = gsub("Cerastoderma edule","C. edule", Species),
         Species = gsub("Loripes orbiculatus","L. orbi.", Species),
         Species = gsub("Macoma balthica","M. balthica", Species),
         Species = gsub("Abra tenuis","A. tenuis", Species),
         Species = gsub("Mya arenaria","M. arenaria", Species),
         Species = gsub("Ruditapes philippinarum","R. phili.", Species))

density_by_specie_ci <- df_bivalve %>% 
  group_by(Species) %>% 
  summarise(
    n = sum(!is.na(Density)),
    mean_density = mean(Density, na.rm = TRUE),
    sd = sd(Density, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  mutate(
    sd = if_else(is.na(sd), 0, sd),
    se = sd / sqrt(pmax(n, 1)),
    ci95 = qt(0.975, df = pmax(n - 1, 1)) * se
  )

species_levels <- density_by_specie_ci %>%
  arrange(mean_density) %>%
  pull(Species)

# Rebuild your first plot as an object (p1) using fixed factor levels
p1 <- ggplot(density_by_specie_ci,
             aes(x = factor(Species, levels = species_levels), y = mean_density)) +
  geom_col(width = 0.7, fill = "grey70") +
  geom_errorbar(aes(ymin = mean_density - ci95, ymax = mean_density + ci95),
                width = 0.2, linewidth = 0.6) +
  coord_flip() +
  labs(
    title = "Average Density by Species (±95% CI)",
    x = "Species",
    y = "Mean Density (ind/m²)"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.x = element_text(margin = margin(t = 8)),
    axis.title.y = element_text(margin = margin(r = 8))
  )

# --- Presence (% of cores) per species ---
total_cores <- dplyr::n_distinct(df_bivalve$Core)

presence_by_specie <- df_bivalve %>%
  filter(!is.na(Abondance), Abondance > 0) %>%         # presence if count > 0
  group_by(Species) %>%
  summarise(cores_present = n_distinct(Core), .groups = "drop") %>%
  mutate(
    percent_cores = 100 * cores_present / total_cores
  )

p2 <- ggplot(presence_by_specie,
             aes(x = factor(Species, levels = species_levels),
                 y = percent_cores)) +
  geom_col(width = 0.7, fill = "grey70") +
  coord_flip() +
  labs(
    title = "Occurrence",
    x = NULL,
    y = "Cores with species (%)"
  ) +
  scale_y_continuous(limits = c(0, 100),
                     expand = expansion(mult = c(0, .05)),
                     labels = function(x) paste0(x, "%")) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.y = element_blank()
  )

# --- Side-by-side with patchwork ---
p1 + p2 + plot_layout(widths = c(2, 1))

```

@fig-BivDensity_m2 shows the mean density of each bivalve species across the 60 cores. In total, nine distinct species were identified. The most common was *Scrobicularia plana* (209 individuals per m², on average, present in about 77% of cores), whereas *Ruditapes decussatus* was the least common (0.95 individuals per m²,  present in about 1% of cores).

## Bivalve diversity by core

```{r Shannon index}
#| label: fig-Biv_diversity_m2
#| fig-cap: Interactive lollipop charts of bivalve diversity per core (n = 60). For each core (colored by site), we show Shannon diversity (H′), species richness (S), and Pielou evenness (J′). Metrics were computed from species‐level counts; H′ uses natural logarithms and J′ = H′/ln(S). Lines run from 0 to the core’s value and points mark the estimate; cores with no identified bivalves appear with H′ = 0 and J′ = 0. Hover to see exact values. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"


library(dplyr)
library(tidyr)
library(vegan)
library(ggplot2)
library(ggiraph)
library(scales)
library(tidytext)  # for reorder_within / scale_y_reordered
library(glue)
library(brms)       # Bayesian models via Stan
library(posterior) 

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia","Scrobicularia",Species),
         Species = gsub("derussatus","decussatus", Species))

# --- Core/species universes ---
cores   <- df_bivalve %>% distinct(Core, Site)  # one site per core expected
species <- df_bivalve %>% distinct(Species)

# sanity check: duplicated core->site?
dup_cores <- cores %>% count(Core) %>% filter(n > 1)
if (nrow(dup_cores) > 0) {
  warning("Some cores map to multiple Sites; check 'cores' table.")
}

# --- Long community table with all Core x Species (zeros filled) ---
comm_long <- df_bivalve %>%
  group_by(Core, Species) %>%
  summarise(Abund = sum(Abondance, na.rm = TRUE), .groups = "drop") %>%
  complete(Core = cores$Core, Species = species$Species, fill = list(Abund = 0))

# --- Wide matrix for vegan ---
comm <- comm_long %>%
  pivot_wider(names_from = Species, values_from = Abund, values_fill = 0) %>%
  arrange(Core)

mat <- as.matrix(comm[, -1, drop = FALSE])

# --- Diversity metrics per core ---
H <- vegan::diversity(mat, index = "shannon")      # may be NA for all-zero rows
S <- vegan::specnumber(mat)
J <- ifelse(S > 0, H / log(S), 0)
N <- rowSums(mat)

# replace NA H with 0 for empty cores
H[is.na(H)] <- 0

shannon_by_core <- tibble(
  Core       = comm$Core,
  Shannon_H  = as.numeric(H),
  Richness_S = as.numeric(S),
  Evenness_J = as.numeric(J),
  N_total    = as.integer(N)
) %>%
  left_join(cores, by = "Core")  # safe: 1 row per Core

# --- Long for plotting ---
long <- shannon_by_core %>%
  pivot_longer(c(Shannon_H, Richness_S, Evenness_J),
               names_to = "metric", values_to = "value") %>%
  mutate(
    metric = recode(metric,
      Shannon_H  = "Shannon H′",
      Richness_S = "Richness S",
      Evenness_J = "Evenness J′"
    ),
    tooltip = glue(
      "<b>{Core}</b><br/>Site: {Site}<br/>{metric}: {round(value, 3)}<br/>",
      "Total individuals: {N_total}"
    ),
    Core_ord = reorder_within(Core, value, metric),
    data_id  = paste(Core, metric, sep = "::")   # unique per facet row
  )

# --- Interactive lollipop chart (one row per Core per metric) ---
p <- ggplot(long, aes(x = value, y = Core  , color = Site)) +
  geom_segment_interactive(
    aes(x = 0, xend = value, yend = Core  , tooltip = tooltip, data_id = data_id),
    linewidth = 0.6, alpha = 0.55
  ) +
  geom_point_interactive(
    aes(tooltip = tooltip, data_id = data_id),
    size = 3
  ) +
  facet_wrap(~ metric, scales = "free_x", ncol = 3) +
  scale_y_reordered() +
  labs(title = "Bivalve Diversity by Core (interactive)", x = NULL, y = "Core") +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.major.y = element_blank(),
    legend.position = "top"
  )

girafe(
  ggobj = p,
  width_svg = 10, height_svg = 8,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "multiple", css = "stroke-width:3;"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 4)
  )
)

#### Stats


# # Data we built earlier
# div <- shannon_by_core %>%
#   select(Core, Site, Shannon_H, Richness_S, Evenness_J) %>%
#   mutate(Site = factor(Site, levels = c("L","H")))  # baseline = L
# 
# # For Beta regression (J' in (0,1)), move exact 0/1 slightly inside using Smithson-Verkuilen
# N <- nrow(div)
# div <- div %>%
#   mutate(Evenness_beta = (Evenness_J * (N - 1) + 0.5) / N)
# 
# # ---------- 1) Shannon H′ : Student-t (robust Gaussian) ----------
# fit_H <- brm(
#   Shannon_H ~ 0 + Site,               # group means directly
#   data   = div,
#   family = student(),
#   prior  = c(
#     prior(normal(0, 5), class = "b"),
#     prior(student_t(3, 0, 2.5), class = "sigma"),
#     prior(gamma(2, 0.1), class = "nu")
#   ),
#   chains = 4, iter = 4000, cores = 4, seed = 1
# )
# 
# draws_H <- as_draws_df(fit_H)
# diff_H  <- draws_H$b_SiteH - draws_H$b_SiteL    # posterior of H - L (on original scale)
# 
# # ---------- 2) Richness S : Negative Binomial ----------
# fit_S <- brm(
#   Richness_S ~ 0 + Site,
#   data   = div,
#   family = negbinomial(),              # allows overdispersion
#   prior  = c(
#     prior(normal(0, 2), class = "b"),  # on log mean
#     prior(exponential(1), class = "shape")
#   ),
#   chains = 4, iter = 4000, cores = 4, seed = 2
# )
# 
# # Work on the response scale (expected richness)
# epred_S <- posterior_epred(fit_S, newdata = tibble(Site = factor(c("H","L"), levels = c("L","H"))))
# diff_S  <- epred_S[, 1] - epred_S[, 2]          # H - L (response scale)
# 
# # ---------- 3) Evenness J′ : Beta ----------
# fit_J <- brm(
#   Evenness_beta ~ 0 + Site,
#   data   = div,
#   family = Beta(),
#   prior  = c(
#     prior(normal(0, 1.5), class = "b"),  # on logit(mu)
#     prior(gamma(2, 0.5), class = "phi")
#   ),
#   chains = 4, iter = 4000, cores = 4, seed = 3
# )
# 
# # Expected evenness on response scale
# epred_J <- posterior_epred(fit_J, newdata = tibble(Site = factor(c("H","L"), levels = c("L","H"))))
# diff_J  <- epred_J[, 1] - epred_J[, 2]          # H - L
# 
# # ---------- Summaries (posterior contrasts) ----------
# summ <- function(x, rope = c(NA, NA)) {
#   tibble(
#     mean    = mean(x),
#     median  = median(x),
#     ci_low  = quantile(x, 0.025),
#     ci_high = quantile(x, 0.975),
#     p_gt0   = mean(x > 0),
#     p_lt0   = mean(x < 0),
#     rope_lo = rope[1],
#     rope_hi = rope[2],
#     rope_in = if (any(is.na(rope))) NA_real_ else mean(x > rope[1] & x < rope[2])
#   )
# }
# 
# # Set small ROPEs (adjust to your scientific relevance)
# rope_H <- c(-0.10,  0.10)   # Shannon units
# rope_S <- c(-1.00,  1.00)   # species
# rope_J <- c(-0.05,  0.05)   # evenness units
# 
# results_bayes <- bind_rows(
#   summ(diff_H, rope_H) %>% mutate(metric = "Shannon H′ (H–L)"),
#   summ(diff_S, rope_S) %>% mutate(metric = "Richness S (H–L)"),
#   summ(diff_J, rope_J) %>% mutate(metric = "Evenness J′ (H–L)")
# ) %>% select(metric, everything())
# 
# results_bayes
```

@fig-Biv_diversity_m2 shows per-core diversity for the two areas. Each dot is a core (colored by site) and panels display Shannon diversity (H′), species richness (S), and Pielou evenness (J′). Cores from area H generally sit higher for H′ and S, with less separation for J′.

Bayesian comparisons (reported as H–L) supported these patterns. Shannon diversity was higher in site H, with a mean difference of +0.365 (95% CrI [0.155, 0.579]) and a posterior probability of $P(H\!-\!L>0)=1.00$. Very little posterior mass fell within a ±0.10 region of practical equivalence (ROPE), indicating that the increase was both statistically credible and ecologically meaningful. Species richness was also greater in H, with an average difference of +1.23 species per core (95% CrI \[0.17, 2.31], $P>0=0.988$). Approximately one-third of the posterior distribution lay within a ±1 species ROPE, suggesting a positive but modest gain in richness. In contrast, evenness showed only a small and uncertain difference +0.116 (95% CrI \[−0.020, 0.247], $P>0=0.956$), with \~15% of the posterior mass within a ±0.05 ROPE.

Overall, area H hosts richer and more diverse bivalve assemblages than area L, while evenness is at most slightly higher in H and may be similar between areas.

## Relationship between bivalve abundance and seagrass biomass

```{r Biv_seagrass}
#| label: fig-Biv_seagrass_m2
#| fig-cap: Density of bivalves in relation with the total biomass of seagrass (sum of above ground and below ground biomass) for site H and L. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(tidyr)
library(vegan)
library(ggplot2)
library(ggiraph)
library(scales)
library(tidytext)  # for reorder_within / scale_y_reordered
library(glue)
library(brms)       # Bayesian models via Stan
library(posterior) 

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia","Scrobicularia",Species),
         Species = gsub("derussatus","decussatus", Species))

# --- Core/species universes ---
cores   <- df_bivalve %>% distinct(Core, Site)  # one site per core expected
species <- df_bivalve %>% distinct(Species)

# sanity check: duplicated core->site?
dup_cores <- cores %>% count(Core) %>% filter(n > 1)
if (nrow(dup_cores) > 0) {
  warning("Some cores map to multiple Sites; check 'cores' table.")
}

# --- Long community table with all Core x Species (zeros filled) ---
comm_long <- df_bivalve %>%
  group_by(Core, Species) %>%
  summarise(Abund = sum(Abondance, na.rm = TRUE), .groups = "drop") %>%
  complete(Core = cores$Core, Species = species$Species, fill = list(Abund = 0))

# --- Wide matrix for vegan ---
comm <- comm_long %>%
  pivot_wider(names_from = Species, values_from = Abund, values_fill = 0) %>%
  arrange(Core)

mat <- as.matrix(comm[, -1, drop = FALSE])

# --- Diversity metrics per core ---
H <- vegan::diversity(mat, index = "shannon")      # may be NA for all-zero rows
S <- vegan::specnumber(mat)
J <- ifelse(S > 0, H / log(S), 0)
N <- rowSums(mat)

# replace NA H with 0 for empty cores
H[is.na(H)] <- 0

shannon_by_core <- tibble(
  Core       = comm$Core,
  Shannon_H  = as.numeric(H),
  Richness_S = as.numeric(S),
  Evenness_J = as.numeric(J),
  N_total    = as.integer(N)*correction_factor
) %>%
  left_join(cores, by = "Core") 

# --- biomass (convert to g/m²) ---
dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A * correction_factor,
         B = B * correction_factor)


df_bivalve_seagrass <- shannon_by_core %>% 
left_join(dryweight, by = c("Core" = "Station")) %>% 
  mutate(overall_biomass = A+B)


# Data for the plot (remove NAs and build tooltips)
plot_df <- df_bivalve_seagrass %>%
  filter(is.finite(A), is.finite(Shannon_H)) %>%
  mutate(
    tooltip = glue(
      "<b>Core:</b> {Core}<br/>",
      "<b>Site:</b> {Site}<br/>",
      "<b>Shannon H′:</b> {round(Shannon_H, 3)}<br/>",
      "<b>Above-ground biomass A:</b> {number(A, accuracy = 0.1)} g/m²<br/>",
      "<b>Below-ground biomass B:</b> {number(B, accuracy = 0.1)} g/m²<br/>",
      "<b>Total biomass:</b> {number(overall_biomass, accuracy = 0.1)} g/m²"
    )
  )

# Plot (points are interactive, smooth shown per site)
p <- ggplot(plot_df, aes(x = overall_biomass, y = N_total , color = Site)) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = Core),
                         size = 3, alpha = 0.9) +
  geom_smooth(method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  # geom_smooth(data = plot_df, mapping = aes(x = A, y = Shannon_H),color = "black",method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  labs(
    title = "Bivales per m² vs Seagrass biomass",
    x = "Biomass of seagrass - Above and below - (g/m²)",
    y = "Individuals per m²"
  ) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

g <- girafe(
  ggobj = p,
  width_svg = 9, height_svg = 6,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "single"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 5)
  )
)

g
```

@fig-Biv_seagrass_m2 illustrates the relationship between bivalve density (individuals per m²) and total seagrass biomass (above- and below-ground combined). Overall, bivalve density tends to be higher in site H compared to site L for a given seagrass biomass. In site H, values are more scattered, with several cores exceeding 700 individuals per m², whereas site L shows consistently lower densities, generally below 500 individuals per m². Both sites display a positive, though weak, association between biomass and bivalve density, as indicated by the fitted regression lines, but the wide confidence bands highlight considerable variability. This suggests that while higher seagrass biomass may provide more habitat structure and support larger bivalve populations, other local factors likely contribute to the observed heterogeneity.

## Relation between bivalve diversity and seagrass biomass 

@fig-Biv_seagrass_m2 shows the relationship between bivalve diversity and the total biomass of seagrass (above- and below-ground combined). Overall, no clear association was observed between these two variables, suggesting that bivalve diversity is primarily influenced by other environmental factors rather than seagrass biomass. The only exception was species richness in site L, where a weak positive relationship was apparent: cores with higher seagrass biomass tended to host a greater number of bivalve species.

```{r Biv_Diversity_seagrass}
#| label: fig-Biv_Indices_seagrass_m2
#| fig-cap: Diversity indices of bivalves in relation with the total biomass of seagrass (sum of above ground and below ground biomass) for site H and L. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(tidyr)
library(ggplot2)
library(ggiraph)
library(glue)
library(scales)

df_long <- df_bivalve_seagrass %>%
  dplyr::select(Core, Site, overall_biomass, Shannon_H, Evenness_J, Richness_S) %>%
  pivot_longer(
    cols = c(Shannon_H, Evenness_J, Richness_S),
    names_to = "Metric", values_to = "Value"
  ) %>%
  mutate(
    Metric_lab = recode(Metric,
                        Shannon_H = "Shannon H′",
                        Evenness_J = "Evenness J",
                        Richness_S = "Richness S"),
    tooltip = glue(
      "<b>Core:</b> {Core}<br/>",
      "<b>Site:</b> {Site}<br/>",
      "<b>{Metric_lab}:</b> {round(Value, 3)}<br/>",
      "<b>Total biomass:</b> {number(overall_biomass, accuracy = 0.1)} g/m²"
    )
  )

p_faceted <- ggplot(df_long, aes(x = overall_biomass, y = Value, color = Site)) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = Core), size = 3, alpha = 0.9) +
  geom_smooth(method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  facet_wrap(~ Metric_lab, scales = "free_y", ncol = 2) +
  labs(
    title = "Biodiversity indices vs seagrass biomass",
    x = "Biomass of seagrass - Above and below - (g/m²)", y = NULL
  ) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

g_faceted <- girafe(
  ggobj = p_faceted,
  width_svg = 10, height_svg = 7,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "single"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 5)
  )
)

g_faceted  


```


