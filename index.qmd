---
title: "M2 Assignement"
author: "Simon Oiry"
editor_options: 
  chunk_output_type: console
---


This page demonstrates how to process the data just as the student should, using exactly the same dataset available to them. It can serve as a reference or correction for the student’s assignment.

::: {style="text-align: center; margin-top: 20px;"}
<button onclick="window.open(&#39;https://github.com/SigOiry/Fieldtrip_Rewrite_Sept2025/raw/refs/heads/main/Output/Data_REWRITE_Bourgneuf_bay.zip&#39;, &#39;_blank&#39;);" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">

Download all the data of that campaign
</button>
:::

# Study area & Methods

A field campaign was organized with Master’s students from the ACES and EBM programs. It took place in the seagrass meadow of Bourgneuf Bay, near the town of Barbâtre on Noirmoutier Island (@fig-Map_BB), on September 9th during low tide. The campaign had a dual purpose: to introduce students to the ecosystem and to collect a total of 60 sediment cores, sampling the top 15–20 cm of the substrate. Two sites were selected for coring. A historical analysis of the meadow over the past 40 years was carried out to identify areas with the most consistent and the most variable seagrass cover. Based on this analysis, site L was chosen in a zone that has shown strong variability in seagrass cover, while site H was located in an area with consistently high seagrass density over the same period.

At both sites, sampling locations were chosen to represent a range of seagrass percent cover. At each station, a photo-quadrat was taken using a 0.25 m² quadrat to estimate seagrass cover. Sediment cores were then collected using a 15 cm diameter PVC tube. Each core was cleaned to remove sediment, retaining only seagrass leaves and rhizomes as well as bivalves. The location of each sampling station was recorded using an Emlid Reach RS2+ GNSS receiver with RTK corrections from the Teria Network.


```{r image patchwork}
#| echo: false
#| error: false
#| message: false
#| warning: false
#| fig-width: 10
#| fig-height: 10
#| out-width: "95%"
#| label: fig-images
#| fig-cap: Patchwork of the 60 photo-quadrat corresponding to the 60 cores performed during the Rewrite field campaign of Bourgneuf Bay. From top-left to bottom right H_01 to H_30 followed by L_01 to L_30.

htmltools::HTML('
<figure>
  <img id="gridimg" src="data/imgs/grid.png" alt="Patchwork of the 60 photo-quadrats" style="max-width:95%; cursor:grab; touch-action:none;" />
</figure>

<link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/@panzoom/panzoom/dist/panzoom.min.js">
<script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom/dist/panzoom.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
  const el = document.getElementById("gridimg");
  const pz = Panzoom(el, { maxScale: 8, contain: "outside" });
  el.parentElement.addEventListener("wheel", pz.zoomWithWheel);
});
</script>
')

```

Back in the lab, each sample was sorted to separate leaves (above-ground biomass) from rhizomes (below-ground biomass). Both fractions were then dried at 60 °C for 48 hours, after which they were weighed for each sampling station.

In order to convert the biomass of the core to a biomass in m² A conversion factor has been applied to each biomass measurements : 

$$
\begin{align*}
Biomass_{m^{2}} &= \frac{100 \times 100}{Core_{Area}} \times Biomass_{Core} \\[6pt]
Core_{Area} &= \pi \times \left(\tfrac{15}{2}\right)^{2}
\end{align*}
$$

At the same time as sorting the above- and below-ground biomass, students also sorted living bivalves, recording the number of individuals of each species. The bivalve taxonomy was verified by a taxonomic expert from [Bio-Littoral](https://bio-littoral.fr).

To map the entire seagrass meadow, a Sentinel-2 image acquired on 6 September 2025, three days prior to the field campaign, was downloaded from the Copernicus Open Access Hub of the European Space Agency. The image was obtained at Level-2A processing, meaning that it had already been atmospherically corrected using the Sen2Cor algorithm and ortho-rectified to provide surface reflectance values in a cartographic geometry. 

```{r leafletmap}
#| fig-cap: Map of Bourgneuf Bay Sampling site
#| label: fig-Map_BB
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(leaflet)
library(sf)
library(leafem)
library(leaflet.extras2)
library(terra)

# folder structure: ./www/imgs/...
img_list <- list.files("data/imgs", recursive = TRUE, full.names = TRUE, pattern = "\\.jpg$") %>%
  tibble(path = .) %>%
  mutate(filename = basename(path),
         station  = substr(filename, 1, 4),
         url      = paste0(file.path("imgs", filename)))

mask <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>%
  st_transform(4326)


mask_S2 <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>% 
  st_buffer(-20)  %>%
  st_transform(4326)

img <- rast("data/S2_Meadow.tif") %>% 
  project("EPSG:4326") %>% 
  crop(mask_S2, mask = T) 
  
Points <- sf::st_read("data/shp/Core_Location/Points.shp", quiet = TRUE) %>%
  st_transform(4326) %>%
  left_join(img_list, by = c("Name" = "station")) %>%
  filter(!is.na(url)) %>% 
  mutate(Site = substr(Name,1,1))

pal <- colorFactor(
  palette = "Set2",   # you can use "Dark2", "Paired", "viridis", etc.
  domain  = Points$Site
)

# --- map ---
leaflet() %>%
  setView(lng = -2.176695, lat = 46.962474, zoom = 15) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery",
                   options = providerTileOptions(minZoom = 8, maxZoom = 20)) %>%
  addRasterRGB(img,r = 4, g = 3, b = 2,
               group = "Sentinel-2 image") %>% 
 addCircleMarkers(
    data = Points,
    radius = 3,
    color = "white",      # outline color
    fillColor = "white",  # fill color
    fillOpacity = 0.8,
    group = "Coring stations",
    popup = ~sprintf("<b>Sample:</b> %s<br><img src='%s' width='300'/>", Name, url)
  ) %>%
  addLayersControl(overlayGroups = c("Coring stations","Sentinel-2 image"),
                   options = layersControlOptions(collapsed = FALSE))

dir.create("docs/imgs")

copying <- file.copy(
    from = list.files("data/imgs", pattern = ".jpg",full.names = TRUE),
    to   = list.files("data/imgs", pattern = ".jpg",full.names = TRUE) %>% gsub("data","docs",.),
    recursive = TRUE,
    overwrite = TRUE
)

# htmlwidgets::saveWidget(plot_S2, file="maps/map_Bathy_Quiberon.html", selfcontained = F)

```

# Results 
## Mapping of the meadow

```{r Map_of_NDVI}
#| fig-cap: Map of NDVI of the meadow of Bourgneuf Bay
#| label: fig-Map_NDVI
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(leaflet)
library(sf)
library(leafem)
library(leaflet.extras2)
library(terra)

mask <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>%
  st_transform(4326)

mask_S2 <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>% 
  st_buffer(-20)  %>%
  st_transform(4326)

img <- rast("data/S2_Meadow.tif") %>% 
  project("EPSG:4326") %>% 
  crop(mask_S2, mask = T)

Points <- sf::st_read("data/shp/Core_Location/Points.shp", quiet = TRUE) %>%
  st_transform(4326) %>%
  # left_join(img_list, by = c("Name" = "station")) %>%
  # filter(!is.na(url)) %>% 
  mutate(Site = substr(Name,1,1))

pal <- colorFactor(
  palette = "Set2",   # you can use "Dark2", "Paired", "viridis", etc.
  domain  = Points$Site
)

NDVI <- ((img$S2_Meadow_8-1000)-(img$S2_Meadow_4-1000))/((img$S2_Meadow_8-1000)+(img$S2_Meadow_4-1000))

# create a color palette (viridis)
pal_ndvi <- colorNumeric(
  palette = viridis::viridis(256),
  domain = values(NDVI),
  na.color = "transparent"
)

# --- map ---
leaflet() %>%
  setView(lng = -2.176695, lat = 46.962474, zoom = 15) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery",
                   options = providerTileOptions(minZoom = 8, maxZoom = 20)) %>%
  addRasterImage(NDVI,
                 colors = pal_ndvi,
                 opacity = 0.8,
                 group = "NDVI") %>%
  addCircleMarkers(
    data = Points,
    radius = 3,
    color = "black",      # outline color
    fillColor = "black",  # fill color
    fillOpacity = 0.8,
    group = "Coring stations",
    popup = ~sprintf("<b>Sample:</b> %s<br>", Name)
  ) %>%
  # wire up click‐popup: show value with 2 decimals
  addImageQuery(
    # map    = .,
    x = NDVI[[1]],
    project = TRUE,
    layerId= "NDVI",
    type   = "mousemove",
    digits = 2,
    prefix = ""
  ) %>% 
  addLayersControl(
    overlayGroups = c("NDVI", "Coring stations"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    pal = pal_ndvi,
    values = values(NDVI),
    title = "NDVI",
    position = "bottomright"
  )

stat_meadow <- NDVI %>% 
  as_tibble() %>% 
  dplyr::filter(S2_Meadow_8 > 0) %>% 
  reframe(mean = mean(S2_Meadow_8),
         min = min(S2_Meadow_8),
         max = max(S2_Meadow_8))
```

@fig-Map_NDVI is showing the NDVI over the meadow. Overall the NDVI of non-water pixel is `r round(stat_meadow$mean,2)` with a maximum of `r round(stat_meadow$max,2)`. The average of NDVI over the meadow is particularly low in 2025, and is among the lowest values recorded in September since the start of the remote sensing acquisitions in the 1970's.

## Biomass vs NDVI

Only in Zone H, before coring, a hyperspectral signature of the sample
was taken using an ASD Fieldspec HandHeld 2. The instrument was
calibrated in the field for reflectance acquisition using a Spectralon
with a 99% reflective Lambertian surface (No radiance measurement has
been done). @fig-hyperspectral_m2 shows that a range of biomass was sampled during the field campaign, with H_04 having the least absorption in the red, indicating a low amount of chlorophyll-a, and H_08 showing the greatest absorption in the red part of the electromagnetic spectrum.

```{r Hyperspectral signature}
#| label: fig-hyperspectral_m2
#| fig-cap: Relationship between the NDVI and the above ground biomass of seagrasses sampled in site H. For each fit, the R-square and the Root mean square error are displayed.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| cache: false
#| out-width: "95%"

library(ggplot2)
library(ggiraph)
library(scales)
library(dplyr)
library(tidyverse)
library(plotly)

df_sp <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = T),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  mutate(ref_std = (ref_mean - min(ref_mean))/(max(ref_mean)-min(ref_mean))) %>% 
  dplyr::select(-sd) %>% 
  pivot_longer(c(ref_mean,ref_std), names_to = "Proc",values_to = "value") %>% 
  ungroup() %>% 
  mutate(Proc = case_when(Proc == "ref_mean" ~ "Raw",
                          T ~ "Standardised"))


# df_sp already created above

# make spectra a nicely ordered factor (optional)
df_sp <- df_sp %>%
  arrange(spectra, Wavelength) %>%
  mutate(spectra = factor(spectra, levels = sort(unique(spectra))))

p <- ggplot(
  df_sp,
  aes(x = Wavelength, y = value, color = spectra, group = spectra)
) +
  facet_wrap(~Proc, scales = "free")+
  # interactive line: tooltip shows spectra; data_id enables hover styling
  geom_line_interactive(
    aes(tooltip = paste0("Spectra: ", spectra),
        data_id  = spectra),
    linewidth = 0.9, alpha = 0.9, show.legend = F
  ) +
  scale_color_viridis_d(option = "viridis", end = 0.95) +
  scale_y_continuous(labels = label_percent(accuracy = 1)) +
  labs(
    x = "Wavelength (nm)",
    y = "Reflectance",
    color = "Spectra"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11),
    axis.title   = element_text(size = 13, face = "bold"),
    axis.text    = element_text(size = 11),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 7, height_svg = 5,
  options = list(
    # thicken the line you hover, fade others
    opts_hover(css = "stroke-width:2.5px;"),
    opts_hover_inv(css = "opacity:0.25;"),
    # nicer tooltip
    opts_tooltip(opacity = .95, css = "padding:6px; font-size:12px;")
  )
)
```

## Above ground biomass

From the hyperspectral signatures presented in @fig-hyperspectral_m2, the Normalized Difference Vegetation Index (NDVI) was computed for each sampling station. To evaluate how well this index can predict seagrass biomass, we examined its relationship with both above- and below-ground dry weight biomass. Several functional forms were tested, including linear, quadratic, log-linear, exponential, and power-law models, in order to capture potential nonlinearities in the NDVI–biomass relationship. For each model, the goodness of fit was assessed using the coefficient of determination (R²) and the root mean square error (RMSE).

```{r hyperspectral NDVI_ABiomass}
#| label: fig-hyperspectral_NDVI_ABiomass
#| fig-cap: Relationship between the NDVI of hyperspectral measurement and the dryweight of above ground biomass of seagrass sampled in zone H.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(purrr)
library(broom)
library(ggplot2)
library(minpack.lm)
library(patchwork)

Core_Diameter <- 15 ### diameter of the core used for sampling (in cm)

core_area <- pi*((Core_Diameter/2)^2) #### Area of the core

correction_factor <- (100*100)/core_area #### Correction factor to convert the dry weight to g/m²

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A*correction_factor,
         B = B*correction_factor, 
         Area = substr(Station,1,1))

df_NDVI <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = TRUE),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  reframe(
    RED = ref_mean[which.min(abs(Wavelength - 670))],
    NIR = ref_mean[which.min(abs(Wavelength - 800))],
    NDVI = (NIR - RED) / (NIR + RED)
  ) %>% 
  left_join(dryweight, by = c("spectra" = "Station")) %>% 
  dplyr::select(-c(Area,NIR,RED))


#--- Data (ensure finite, drop NAs) ---
dat <- df_NDVI %>%
  select(NDVI, A) %>%
  filter(is.finite(NDVI), is.finite(A))

# --- helpers ---
metrics <- function(y, yhat) {
  sse <- sum((y - yhat)^2)
  sst <- sum((y - mean(y))^2)
  tibble(R2 = 1 - sse/sst, RMSE = sqrt(mean((y - yhat)^2)))
}
smear_factor <- function(resid) exp(0.5 * stats::var(resid))

# prediction grid
ndvi_seq <- tibble(NDVI = seq(min(dat$NDVI, na.rm = TRUE),
                              max(dat$NDVI, na.rm = TRUE), length.out = 200))

# ---- Model specs: fit, predict (original scale), label ----
specs <- list(
  linear = list(
    label = "Linear (A ~ NDVI)",
    fit = function(d) lm(A ~ NDVI, data = d),
    pred = function(fit, newd) tibble(A_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f + %.3f·NDVI", b[1], b[2])
    }
  ),
  quadratic = list(
    label = "Quadratic (A ~ NDVI + NDVI^2)",
    fit = function(d) lm(A ~ poly(NDVI, 2, raw = TRUE), data = d),
    pred = function(fit, newd) tibble(A_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f + %.3f·NDVI + %.3f·NDVI²", b[1], b[2], b[3])
    }
  ),
  log_linear = list(
    label = "Log-linear (A ~ log(NDVI))",
    fit = function(d) { d2 <- d %>% filter(NDVI > 0); lm(A ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      tibble(A_hat = as.numeric(predict(fit, newd2)))
    },
    eq  = function(fit) { b <- coef(fit); sprintf("A = %.3f + %.3f·log(NDVI)", b[1], b[2]) }
  ),
  exponential = list(
    label = "Exponential (A = a·e^{b·NDVI})",
    fit = function(d) { d2 <- d %>% filter(A > 0); lm(log(A) ~ NDVI, data = d2) },
    pred = function(fit, newd) {
      sf <- smear_factor(residuals(fit))
      tibble(A_hat = as.numeric(exp(predict(fit, newd)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f·e^{%.3f·NDVI}", exp(b[1]), b[2])
    }
  ),
  power = list(
    label = "Power (A = a·NDVI^b)",
    fit = function(d) { d2 <- d %>% filter(A > 0, NDVI > 0); lm(log(A) ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      sf <- smear_factor(residuals(fit))
      tibble(A_hat = as.numeric(exp(predict(fit, newd2)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("A = %.3f·NDVI^{%.3f}", exp(b[1]), b[2])
    }
  )
)

# ---- Bootstrap CI function (shared) ----
bootstrap_ci <- function(spec, d, newd, B = 400, conf = 0.95, seed = 123) {
  set.seed(seed)
  fit0  <- spec$fit(d)
  pred0 <- spec$pred(fit0, newd) %>% pull(A_hat)
  obs_hat <- spec$pred(fit0, d) %>% pull(A_hat)
  stats0  <- metrics(d$A, obs_hat)

  P <- matrix(NA_real_, nrow = nrow(newd), ncol = B)
  b <- 1
  while (b <= B) {
    idx <- sample(seq_len(nrow(d)), replace = TRUE)
    db  <- d[idx, , drop = FALSE]
    fb  <- try(spec$fit(db), silent = TRUE)
    if (inherits(fb, "try-error")) next
    pb  <- try(spec$pred(fb, newd) %>% pull(A_hat), silent = TRUE)
    if (inherits(pb, "try-error") || any(!is.finite(pb))) next
    P[, b] <- pb
    b <- b + 1
  }
  alpha <- (1 - conf) / 2
  lwr <- apply(P, 1, quantile, probs = alpha, na.rm = TRUE)
  upr <- apply(P, 1, quantile, probs = 1 - alpha, na.rm = TRUE)

  list(fit = fit0,
       grid = bind_cols(newd, tibble(A_hat = pred0, lwr = lwr, upr = upr)),
       stats = stats0)
}

# ---- Run the 5 models ----
results_list <- purrr::imap(specs, function(spec, key) {
  res <- bootstrap_ci(spec, dat, ndvi_seq, B = 400, conf = 0.95, seed = 42)
  list(
    key   = key,
    label = spec$label,
    fit   = res$fit,
    grid  = res$grid,
    eq    = specs[[key]]$eq(res$fit),
    stats = res$stats
  )
})

# ---- Build one plot per model ----
make_panel <- function(res) {
  eq_text  <- res$eq
  r2_text  <- sprintf("R² = %.3f | RMSE = %.2f", res$stats$R2, res$stats$RMSE)
  # lbl_text <- paste(eq_text, r2_text, sep = "\n")
  lbl_text = r2_text

  ggplot() +
    geom_point(data = dat, aes(NDVI, A), alpha = 0.8) +
    geom_ribbon(data = res$grid, aes(NDVI, ymin = lwr, ymax = upr), alpha = 0.2) +
    geom_line(data = res$grid, aes(NDVI, A_hat), linewidth = 1) +
    labs(title = res$label, x = "NDVI", y = "Above ground biomass (g/m²)") +
    annotate("text", x = 0.15, y = Inf, hjust = 0, vjust = 1.2,
             label = lbl_text, size = 3) +
    theme_minimal(base_size = 15)+
    theme(plot.title = element_text(size = 10))
}

panels <- lapply(results_list, make_panel)

# ---- Patchwork layout for 5 panels ----
# wrap_plots(panels, ncol = 2)

panels[2]
```

$$ 
\begin{flalign*} 
\text{Quadratic: } & \quad AboveGround_{biomass} = -0.643 + 83.650 \cdot \mathrm{NDVI} + 120.532 \cdot \mathrm{NDVI}^{2} && \\[6pt] 
\end{flalign*} 
$$

The results, summarized in @fig-hyperspectral_NDVI_ABiomass, show that the quadratic model provided the best fits, with R² values around 0.657 and lowest RMSE compared to the other formulations, indicating that NDVI is a reliable predictor of above-ground seagrass biomass in this meadow.
 
## Below ground biomass

The relationships between NDVI and below-ground seagrass biomass were generally weaker than those observed for above-ground biomass. Across all functional forms tested (linear, quadratic, log-linear, exponential, and power law), the models explained less variance, with R² values ranging between 0.42 and 0.46 and RMSE around 21 g·m² (@fig-hyperspectral_NDVI_BBiomass). In comparison, the best above-ground models (quadratic and power law) reached R² values of about 0.65 and lower RMSE (~18 g·m²), highlighting a stronger predictive capacity of NDVI for the photosynthetic canopy than for the rhizome and root fraction. Among the below-ground fits, the quadratic and power law formulations again performed slightly better than the others, but improvements over the linear model were marginal. These results confirm that NDVI is more sensitive to variations in above-ground biomass, which directly affect canopy reflectance, whereas below-ground biomass shows only weak indirect correlations with spectral indices derived from hyperspectral measurements.

```{r hyperspectral NDVI_BBiomass}
#| label: fig-hyperspectral_NDVI_BBiomass
#| fig-cap: Relationship between the NDVI of hyperspectral measurement and the dryweight of below ground biomass of seagrass sampled in zone H.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(purrr)
library(broom)
library(ggplot2)
library(minpack.lm)
library(patchwork)
library(tidyverse)

Core_Diameter <- 15 ### diameter of the core used for sampling (in cm)

core_area <- pi*((Core_Diameter/2)^2) #### Area of the core

correction_factor <- (100*100)/core_area #### Correction factor to convert the dry weight to g/m²

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A*correction_factor,
         B = B*correction_factor, 
         Area = substr(Station,1,1))

df_NDVI <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = TRUE),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  reframe(
    RED = ref_mean[which.min(abs(Wavelength - 670))],
    NIR = ref_mean[which.min(abs(Wavelength - 800))],
    NDVI = (NIR - RED) / (NIR + RED)
  ) %>% 
  left_join(dryweight, by = c("spectra" = "Station")) %>% 
  dplyr::select(-c(Area,NIR,RED))


#--- Data (ensure finite, drop NAs) ---
dat <- df_NDVI %>%
  select(NDVI, B) %>%
  filter(is.finite(NDVI), is.finite(B)) %>% 
  rename(Below = "B")

# --- helpers ---
metrics <- function(y, yhat) {
  sse <- sum((y - yhat)^2)
  sst <- sum((y - mean(y))^2)
  tibble(R2 = 1 - sse/sst, RMSE = sqrt(mean((y - yhat)^2)))
}
smear_factor <- function(resid) exp(0.5 * stats::var(resid))

# prediction grid
ndvi_seq <- tibble(NDVI = seq(min(dat$NDVI, na.rm = TRUE),
                              max(dat$NDVI, na.rm = TRUE), length.out = 200))

# ---- Model specs: fit, predict (original scale), label ----
specs <- list(
  linear = list(
    label = "Linear (Below ~ NDVI)",
    fit = function(d) lm(Below ~ NDVI, data = d),
    pred = function(fit, newd) tibble(Below_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f + %.3f·NDVI", b[1], b[2])
    }
  ),
  quadratic = list(
    label = "Quadratic (Below ~ NDVI + NDVI^2)",
    fit = function(d) lm(Below ~ poly(NDVI, 2, raw = TRUE), data = d),
    pred = function(fit, newd) tibble(Below_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f + %.3f·NDVI + %.3f·NDVI²", b[1], b[2], b[3])
    }
  ),
  log_linear = list(
    label = "Log-linear (Below ~ log(NDVI))",
    fit = function(d) { d2 <- d %>% filter(NDVI > 0); lm(Below ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      tibble(Below_hat = as.numeric(predict(fit, newd2)))
    },
    eq  = function(fit) { b <- coef(fit); sprintf("Below = %.3f + %.3f·log(NDVI)", b[1], b[2]) }
  ),
  exponential = list(
    label = "Exponential (Below = a·e^{b·NDVI})",
    fit = function(d) { d2 <- d %>% filter(Below > 0); lm(log(Below) ~ NDVI, data = d2) },
    pred = function(fit, newd) {
      sf <- smear_factor(residuals(fit))
      tibble(Below_hat = as.numeric(exp(predict(fit, newd)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f·e^{%.3f·NDVI}", exp(b[1]), b[2])
    }
  ),
  power = list(
    label = "Power (Below = a·NDVI^b)",
    fit = function(d) { d2 <- d %>% filter(Below > 0, NDVI > 0); lm(log(Below) ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      sf <- smear_factor(residuals(fit))
      tibble(Below_hat = as.numeric(exp(predict(fit, newd2)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("Below = %.3f·NDVI^{%.3f}", exp(b[1]), b[2])
    }
  )
)

# ---- Bootstrap CI function (shared) ----
bootstrap_ci <- function(spec, d, newd, B = 400, conf = 0.95, seed = 123) {
  set.seed(seed)
  fit0  <- spec$fit(d)
  pred0 <- spec$pred(fit0, newd) %>% pull(Below_hat)
  obs_hat <- spec$pred(fit0, d) %>% pull(Below_hat)
  stats0  <- metrics(d$Below, obs_hat)

  P <- matrix(NA_real_, nrow = nrow(newd), ncol = B)
  b <- 1
  while (b <= B) {
    idx <- sample(seq_len(nrow(d)), replace = TRUE)
    db  <- d[idx, , drop = FALSE]
    fb  <- try(spec$fit(db), silent = TRUE)
    if (inherits(fb, "try-error")) next
    pb  <- try(spec$pred(fb, newd) %>% pull(Below_hat), silent = TRUE)
    if (inherits(pb, "try-error") || any(!is.finite(pb))) next
    P[, b] <- pb
    b <- b + 1
  }
  alpha <- (1 - conf) / 2
  lwr <- apply(P, 1, quantile, probs = alpha, na.rm = TRUE)
  upr <- apply(P, 1, quantile, probs = 1 - alpha, na.rm = TRUE)

  list(fit = fit0,
       grid = bind_cols(newd, tibble(Below_hat = pred0, lwr = lwr, upr = upr)),
       stats = stats0)
}

# ---- Run the 5 models ----
results_list <- purrr::imap(specs, function(spec, key) {
  res <- bootstrap_ci(spec, dat, ndvi_seq, B = 400, conf = 0.95, seed = 42)
  list(
    key   = key,
    label = spec$label,
    fit   = res$fit,
    grid  = res$grid,
    eq    = specs[[key]]$eq(res$fit),
    stats = res$stats
  )
})

# ---- Build one plot per model ----
make_panel <- function(res) {
  eq_text  <- res$eq
  r2_text  <- sprintf("R² = %.3f | RMSE = %.2f", res$stats$R2, res$stats$RMSE)
  # lbl_text <- paste(eq_text, r2_text, sep = "\n")
  lbl_text = r2_text

  ggplot() +
    geom_point(data = dat, aes(NDVI, Below), alpha = 0.8) +
    geom_ribbon(data = res$grid, aes(NDVI, ymin = lwr, ymax = upr), alpha = 0.2) +
    geom_line(data = res$grid, aes(NDVI, Below_hat), linewidth = 1) +
    labs(title = res$label, x = "NDVI", y = "Below ground biomass (g/m²)") +
    annotate("text", x = 0.15, y = Inf, hjust = 0, vjust = 1.2,
             label = lbl_text, size = 3) +
    theme_minimal(base_size = 15)+
    theme(plot.title = element_text(size = 10))
}

panels <- lapply(results_list, make_panel)

# ---- Patchwork layout for 5 panels ----
# wrap_plots(panels, ncol = 2)


 panels[[2]]
```

$$
\begin{flalign*}
\text{Quadratic: } & \quad BelowGround_{biomass} = 4.189 + 84.580 \cdot \mathrm{NDVI} + 67.389 \cdot \mathrm{NDVI}^{2} && \\[6pt]
\end{flalign*}
$$

## Total biomass

The relationships between NDVI and the total seagrass biomass were comparable to those observed for above-ground biomass. Among the tested functional forms, the quadratic model provided the best performance, with an R² of 0.643 and an RMSE of 33.1 g·m⁻². However, this RMSE is approximately 18 g·m⁻² higher than that obtained for above-ground biomass, highlighting the weaker predictive capacity of NDVI for total biomass compared to its stronger relationship with the photosynthetic canopy (@fig-hyperspectral_NDVI_TBiomass).


```{r hyperspectral NDVI_TBiomass}
#| label: fig-hyperspectral_NDVI_TBiomass
#| fig-cap: Relationship between the NDVI of hyperspectral measurement and the dryweight of total biomass of seagrass sampled in zone H.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(purrr)
library(broom)
library(ggplot2)
library(minpack.lm)
library(patchwork)
library(tidyverse)

Core_Diameter <- 15 ### diameter of the core used for sampling (in cm)

core_area <- pi*((Core_Diameter/2)^2) #### Area of the core

correction_factor <- (100*100)/core_area #### Correction factor to convert the dry weight to g/m²

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A*correction_factor,
         B = B*correction_factor,
         Total = A + B,
         Area = substr(Station,1,1))

df_NDVI <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = TRUE),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  reframe(
    RED = ref_mean[which.min(abs(Wavelength - 670))],
    NIR = ref_mean[which.min(abs(Wavelength - 800))],
    NDVI = (NIR - RED) / (NIR + RED)
  ) %>% 
  left_join(dryweight, by = c("spectra" = "Station")) %>% 
  dplyr::select(-c(Area,NIR,RED))


#--- Data (ensure finite, drop NAs) ---
dat <- df_NDVI %>%
  select(NDVI, Total) %>%
  filter(is.finite(NDVI), is.finite(Total)) 

# --- helpers ---
metrics <- function(y, yhat) {
  sse <- sum((y - yhat)^2)
  sst <- sum((y - mean(y))^2)
  tibble(R2 = 1 - sse/sst, RMSE = sqrt(mean((y - yhat)^2)))
}
smear_factor <- function(resid) exp(0.5 * stats::var(resid))

# prediction grid
ndvi_seq <- tibble(NDVI = seq(min(dat$NDVI, na.rm = TRUE),
                              max(dat$NDVI, na.rm = TRUE), length.out = 200))

# ---- Model specs: fit, predict (original scale), label ----
specs <- list(
  linear = list(
    label = "Linear (Total ~ NDVI)",
    fit = function(d) lm(Total ~ NDVI, data = d),
    pred = function(fit, newd) tibble(Total_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("Total = %.3f + %.3f·NDVI", b[1], b[2])
    }
  ),
  quadratic = list(
    label = "Quadratic (Total ~ NDVI + NDVI^2)",
    fit = function(d) lm(Total ~ poly(NDVI, 2, raw = TRUE), data = d),
    pred = function(fit, newd) tibble(Total_hat = as.numeric(predict(fit, newd))),
    eq  = function(fit) {
      b <- coef(fit); sprintf("Total = %.3f + %.3f·NDVI + %.3f·NDVI²", b[1], b[2], b[3])
    }
  ),
  log_linear = list(
    label = "Log-linear (Total ~ log(NDVI))",
    fit = function(d) { d2 <- d %>% filter(NDVI > 0); lm(Total ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      tibble(Total_hat = as.numeric(predict(fit, newd2)))
    },
    eq  = function(fit) { b <- coef(fit); sprintf("Total = %.3f + %.3f·log(NDVI)", b[1], b[2]) }
  ),
  exponential = list(
    label = "Exponential (Total = a·e^{b·NDVI})",
    fit = function(d) { d2 <- d %>% filter(Total > 0); lm(log(Total) ~ NDVI, data = d2) },
    pred = function(fit, newd) {
      sf <- smear_factor(residuals(fit))
      tibble(Total_hat = as.numeric(exp(predict(fit, newd)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("Total = %.3f·e^{%.3f·NDVI}", exp(b[1]), b[2])
    }
  ),
  power = list(
    label = "Power (Total = a·NDVI^b)",
    fit = function(d) { d2 <- d %>% filter(Total > 0, NDVI > 0); lm(log(Total) ~ log(NDVI), data = d2) },
    pred = function(fit, newd) {
      newd2 <- newd %>% mutate(NDVI = pmax(NDVI, .Machine$double.eps))
      sf <- smear_factor(residuals(fit))
      tibble(Total_hat = as.numeric(exp(predict(fit, newd2)) * sf))
    },
    eq  = function(fit) {
      b <- coef(fit); sprintf("Total = %.3f·NDVI^{%.3f}", exp(b[1]), b[2])
    }
  )
)

# ---- Bootstrap CI function (shared) ----
bootstrap_ci <- function(spec, d, newd, B = 400, conf = 0.95, seed = 123) {
  set.seed(seed)
  fit0  <- spec$fit(d)
  pred0 <- spec$pred(fit0, newd) %>% pull(Total_hat)
  obs_hat <- spec$pred(fit0, d) %>% pull(Total_hat)
  stats0  <- metrics(d$Total, obs_hat)

  P <- matrix(NA_real_, nrow = nrow(newd), ncol = B)
  b <- 1
  while (b <= B) {
    idx <- sample(seq_len(nrow(d)), replace = TRUE)
    db  <- d[idx, , drop = FALSE]
    fb  <- try(spec$fit(db), silent = TRUE)
    if (inherits(fb, "try-error")) next
    pb  <- try(spec$pred(fb, newd) %>% pull(Total_hat), silent = TRUE)
    if (inherits(pb, "try-error") || any(!is.finite(pb))) next
    P[, b] <- pb
    b <- b + 1
  }
  alpha <- (1 - conf) / 2
  lwr <- apply(P, 1, quantile, probs = alpha, na.rm = TRUE)
  upr <- apply(P, 1, quantile, probs = 1 - alpha, na.rm = TRUE)

  list(fit = fit0,
       grid = bind_cols(newd, tibble(Total_hat = pred0, lwr = lwr, upr = upr)),
       stats = stats0)
}

# ---- Run the 5 models ----
results_list <- purrr::imap(specs, function(spec, key) {
  res <- bootstrap_ci(spec, dat, ndvi_seq, B = 400, conf = 0.95, seed = 42)
  list(
    key   = key,
    label = spec$label,
    fit   = res$fit,
    grid  = res$grid,
    eq    = specs[[key]]$eq(res$fit),
    stats = res$stats
  )
})

# ---- Build one plot per model ----
make_panel <- function(res) {
  eq_text  <- res$eq
  r2_text  <- sprintf("R² = %.3f | RMSE = %.2f", res$stats$R2, res$stats$RMSE)
  # lbl_text <- paste(eq_text, r2_text, sep = "\n")
  lbl_text = r2_text

  ggplot() +
    geom_point(data = dat, aes(NDVI, Total), alpha = 0.8) +
    geom_ribbon(data = res$grid, aes(NDVI, ymin = lwr, ymax = upr), alpha = 0.2) +
    geom_line(data = res$grid, aes(NDVI, Total_hat), linewidth = 1) +
    labs(title = res$label, x = "NDVI", y = "Total biomass (g/m²)") +
    annotate("text", x = 0.15, y = Inf, hjust = 0, vjust = 1.2,
             label = lbl_text, size = 3) +
    theme_minimal(base_size = 15)+
    theme(plot.title = element_text(size = 10))
}

panels <- lapply(results_list, make_panel)

# ---- Patchwork layout for 5 panels ----
# wrap_plots(panels, ncol = 2)


panels[[2]]
```


$$
\begin{flalign*}
\text{Quadratic: } & \quad Total_{biomass} = -4.832 + 168.230 \cdot \mathrm{NDVI} + 187.922 \cdot \mathrm{NDVI}^{2} && \\[6pt]
\end{flalign*}
$$
For both the modeling of the above ground and the below ground biomass the **quadratic** relationship will be used for the rest of the analysis. 

## Mapping the biomass of seagrass across the meadow. 

Using the relationship found in @fig-hyperspectral_NDVI_ABiomass and @fig-hyperspectral_NDVI_BBiomass, the biomass of seagrass can be estimated from the NDVI at the scale of the entire mudflat. 

```{r mapping biomass from NDVI}
#| label: fig-Map_Biomass
#| fig-cap: Map of Above ground Biomass (Left) and Below ground biomass (right) of the seagrass *Zostera noltei* across the entire meadow
#| echo: false
#| eval: true
#| error: false
#| message: false
#| warning: false
#| cache: false
#| out-width: "95%"
#| fig-height: 9
#| fig-width: 4 

library(tidyverse)
library(leaflet)
library(leafem)          # addMouseCoordinates, addImageQuery
library(leaflet.extras2) # (optional extra controls)
library(sf)
library(terra)
library(raster)          # for leaflet raster compatibility
library(RColorBrewer)
library(leafsync) 

mask <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>%
  st_transform(4326)


mask_S2 <- read_sf("data/shp/Meadow_BB.shp") %>%
  st_make_valid() %>% 
  st_buffer(-20)  %>%
  st_transform(4326)

img <- rast("data/S2_Meadow.tif") %>% 
  project("EPSG:4326") %>% 
  crop(mask_S2, mask = T) 
  
NDVI <- ((img$S2_Meadow_8-1000)-(img$S2_Meadow_4-1000))/((img$S2_Meadow_8-1000)+(img$S2_Meadow_4-1000))

A_Biomass <- -0.643+83.65*NDVI + 120.532*(NDVI*NDVI)
values(A_Biomass)[values(A_Biomass)<0] <- 0

B_Biomass <- 4.189+84.58*NDVI + 67.389*(NDVI*NDVI)
values(B_Biomass)[values(B_Biomass)<0] <- 0

rA <- A_Biomass
rB <- B_Biomass

# palettes (different and non-viridis)
palA <- colorNumeric(
  palette = colorRampPalette(brewer.pal(9, "YlOrRd"))(256),
  domain  = raster::values(rA),
  na.color = "transparent"
)

palB <- colorNumeric(
  palette = colorRampPalette(brewer.pal(9, "PuBuGn"))(256),
  domain  = raster::values(rB),
  na.color = "transparent"
)

# a common view (center on mask)
ctr <- st_coordinates(st_centroid(st_union(mask))) %>% as.numeric()

# get min and max values for the rasters
rngA <- range(values(rA), na.rm = TRUE)
rngB <- range(values(rB), na.rm = TRUE)

# --- Map 1: Above-ground biomass (A) ---
mA <- leaflet(options = leafletOptions(minZoom = 8, preferCanvas = TRUE)) |>
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") |>
  setView(lng = ctr[1], lat = ctr[2], zoom = 14) |>
  # addPolygons(data = mask, color = "#444", weight = 1, fill = FALSE, group = "Meadow") |>
  addRasterImage(rA, colors = palA, opacity = 0.85, group = "Above ground", project = TRUE) |>
  addLegend(
    pal = palA,
    values = values(rA),
    title = "Above-ground biomass (g·m²)",
    position = "bottomright",
    labFormat = labelFormat(digits = 0),
    # only show min and max
    bins = c(rngA[1], rngA[2])
  ) |>
  addImageQuery(rA[[1]], project = TRUE, layer = "Above ground", type = "mousemove", digits = 2, prefix = "") |>
  addScaleBar(position = "bottomleft")

# --- Map 2: Below-ground biomass (B) ---
rngB <- range(values(rB), na.rm = TRUE)

mB <- leaflet(options = leafletOptions(minZoom = 8, preferCanvas = TRUE)) |>
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") |>
  setView(lng = ctr[1], lat = ctr[2], zoom = 14) |>
  # addPolygons(data = mask, color = "#444", weight = 1, fill = FALSE, group = "Meadow") |>
  addRasterImage(rB, colors = palB, opacity = 0.85, group = "Below ground", project = TRUE) |>
  addLegend(
    pal = palB,
    values = values(rB),
    title = "Below-ground biomass (g·m²)",
    position = "bottomright",
    labFormat = labelFormat(digits = 0),
    bins = c(rngB[1], rngB[2])  # only min & max
  ) |>
  addImageQuery(rB[[1]], project = TRUE, layer = "Below ground",type = "mousemove", digits = 2, prefix = "") |>
  addScaleBar(position = "bottomleft")


# --- Synchronized view (side-by-side) ---
leafsync::sync(mA, mB)


total_Abiomass = A_Biomass %>% 
  as_tibble() %>% 
  dplyr::filter(S2_Meadow_8 >0) %>% 
  reframe(sum = sum(S2_Meadow_8)* 0.1 * 0.001,
          mean = mean(S2_Meadow_8))

total_Bbiomass = B_Biomass %>% 
  as_tibble() %>% 
  dplyr::filter(S2_Meadow_8 >0) %>% 
  reframe(sum = sum(S2_Meadow_8)* 0.1 * 0.001,
          mean = mean(S2_Meadow_8))
```

@fig-Map_Biomass shows the spatial distribution of above- and below-ground biomass of Zostera noltei across the study site. In total, an estimated **`r round(total_Abiomass$sum,2)` tons** of leaves and **`r round(total_Bbiomass$sum,2)` tons** of roots are present within the study area. The average above ground biomass is `r round(total_Abiomass$mean,2)` g.m² while the below ground biomass averages at `r round(total_Bbiomass$mean,2)` g.m². 

# Bivalves

## Abundance

```{r Bivalve analysis}
#| label: fig-BivDensity_m2
#| fig-cap: Average density of each bivalve specie across all 60 cores (Left) and Percentage of core were each species were found (Right). 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(readxl)
library(patchwork)

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia plana","S. plana",Species),
         Species = gsub("Ruditapes derussatus","R. decu.", Species),
         Species = gsub("Cerastoderma edule","C. edule", Species),
         Species = gsub("Loripes orbiculatus","L. orbi.", Species),
         Species = gsub("Macoma balthica","M. balthica", Species),
         Species = gsub("Abra tenuis","A. tenuis", Species),
         Species = gsub("Mya arenaria","M. arenaria", Species),
         Species = gsub("Ruditapes philippinarum","R. phili.", Species))

density_by_specie_ci <- df_bivalve %>% 
  group_by(Species) %>% 
  summarise(
    n = sum(!is.na(Density)),
    mean_density = mean(Density, na.rm = TRUE),
    sd = sd(Density, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  mutate(
    sd = if_else(is.na(sd), 0, sd),
    se = sd / sqrt(pmax(n, 1)),
    ci95 = qt(0.975, df = pmax(n - 1, 1)) * se
  )

species_levels <- density_by_specie_ci %>%
  arrange(mean_density) %>%
  pull(Species)

# Rebuild your first plot as an object (p1) using fixed factor levels
p1 <- ggplot(density_by_specie_ci,
             aes(x = factor(Species, levels = species_levels), y = mean_density)) +
  geom_col(width = 0.7, fill = "grey70") +
  geom_errorbar(aes(ymin = mean_density - ci95, ymax = mean_density + ci95),
                width = 0.2, linewidth = 0.6) +
  coord_flip() +
  labs(
    title = "Average Density by Species (±95% CI)",
    x = "Species",
    y = "Mean Density (ind/m²)"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.x = element_text(margin = margin(t = 8)),
    axis.title.y = element_text(margin = margin(r = 8))
  )

# --- Presence (% of cores) per species ---
total_cores <- dplyr::n_distinct(df_bivalve$Core)

presence_by_specie <- df_bivalve %>%
  filter(!is.na(Abondance), Abondance > 0) %>%         # presence if count > 0
  group_by(Species) %>%
  summarise(cores_present = n_distinct(Core), .groups = "drop") %>%
  mutate(
    percent_cores = 100 * cores_present / total_cores
  )

p2 <- ggplot(presence_by_specie,
             aes(x = factor(Species, levels = species_levels),
                 y = percent_cores)) +
  geom_col(width = 0.7, fill = "grey70") +
  coord_flip() +
  labs(
    title = "Occurrence",
    x = NULL,
    y = "Cores with species (%)"
  ) +
  scale_y_continuous(limits = c(0, 100),
                     expand = expansion(mult = c(0, .05)),
                     labels = function(x) paste0(x, "%")) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.y = element_blank()
  )

# --- Side-by-side with patchwork ---
p1 + p2 + plot_layout(widths = c(2, 1))

```

@fig-BivDensity_m2 shows the mean density of each bivalve species across the 60 cores. In total, nine distinct species were identified. The most common was *Scrobicularia plana* (209 individuals per m², on average, present in about 77% of cores), whereas *Ruditapes decussatus* was the least common (0.95 individuals per m²,  present in about 1% of cores).

## Bivalve diversity by Site

```{r Shannon index}
#| label: fig-Biv_diversity_m2
#| fig-cap: Boxplot of bivalve diversity per Site (n = 59). For each core (colored by site), we show Shannon diversity (H′), species richness (S), and Pielou evenness (J′). Metrics were computed from species‐level counts; H′ uses natural logarithms and J′ = H′/ln(S).  
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"


library(tidyverse)
library(readxl)
library(vegan)
library(rstatix)
library(ggpubr)

# --- Load & clean ---
Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  filter(Species != "Inconnu") %>% 
  mutate(
    Species = gsub("Scobicularia","Scrobicularia",Species),
    Species = gsub("derussatus","decussatus", Species)
  )

# -------------------------------------------------------------------
# 1) Build CORE x SPECIES table, keep Site per core
# -------------------------------------------------------------------
core_comm <- df_bivalve %>%
  group_by(Core, Site, Species) %>%
  summarise(Abund = sum(Abondance, na.rm = TRUE), .groups = "drop")

core_mat <- core_comm %>%
  pivot_wider(names_from = Species, values_from = Abund, values_fill = 0) %>%
  arrange(Core, Site)

# Species columns (everything numeric except optional 'Core','Site')
species_cols <- setdiff(names(core_mat), c("Core", "Site"))
mat_core <- as.matrix(core_mat[, species_cols, drop = FALSE])
rownames(mat_core) <- core_mat$Core

# -------------------------------------------------------------------
# 2) Diversity indices PER CORE
# -------------------------------------------------------------------
H_core <- vegan::diversity(mat_core, index = "shannon")
S_core <- vegan::specnumber(mat_core)
J_core <- ifelse(S_core > 0, H_core / log(S_core), 0)
N_core <- rowSums(mat_core)

core_indices <- tibble(
  Core       = core_mat$Core,
  Site       = core_mat$Site,
  Shannon_H  = as.numeric(H_core),
  Richness_S = as.numeric(S_core),
  Evenness_J = as.numeric(J_core),
  N_total    = as.integer(N_core)
)

# -------------------------------------------------------------------
# 3) Long format for faceted boxplots + stats by Site
# -------------------------------------------------------------------
core_long <- core_indices %>%
  select(Core, Site, Shannon_H, Richness_S, Evenness_J) %>%
  pivot_longer(-c(Core, Site),
               names_to = "metric", values_to = "value") %>%
  mutate(metric = recode(metric,
                         Shannon_H = "Shannon H′",
                         Richness_S = "Richness S",
                         Evenness_J = "Evenness J′"))

# Kruskal–Wallis per metric
kw_all <- core_long %>%
  group_by(metric) %>%
  kruskal_test(value ~ Site)

# Dunn pairwise per metric
dunn_all <- core_long %>%
  group_by(metric) %>%
  dunn_test(value ~ Site, p.adjust.method = "BH") %>%
  add_xy_position(x = "Site", step.increase = 0.08)   # nicer stacking of brackets

# (Optional) counts per Site for labels
counts <- core_long %>%
  distinct(Core, Site) %>%
  count(Site, name = "n")

# -------------------------------------------------------------------
# 4) Faceted boxplots (one facet per metric) + per-facet Dunn brackets
# -------------------------------------------------------------------
p_facets <- ggplot(core_long, aes(Site, value, fill = Site)) +
  geom_boxplot(width = 0.65, alpha = 0.6, color = "black", outlier.shape = NA) +
  stat_summary(fun = median, geom = "point", shape = 95, size = 7, color = "black") +
  facet_wrap(~ metric, scales = "free_y") +
  scale_fill_brewer(palette = "Set2") +
  guides(fill = "none") +
  labs(title = "Site-level diversity (computed per core)",
       x = NULL, y = NULL) +
  theme_minimal(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    axis.text.x = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

# Add p-value brackets per facet
p_facets + stat_pvalue_manual(
  dunn_all,
  label = "p.adj.signif",    # or "p.adj" for numeric p-values
  tip.length = 0.01,
  bracket.size = 0.8,
  hide.ns = TRUE,
  facet.by = "metric"
)

```

@fig-Biv_diversity_m2 shows the site-level diversity indices computed per core for sites H and L. Evenness (J′) values were similar between sites, with medians close to 0.9. Species richness (S) was significantly higher at site H, with a median of about 3 species per core, compared to only 2 species per core at site L. Likewise, Shannon diversity (H′) was significantly higher at site H, where cores displayed consistently greater diversity compared to site L, which showed lower median values and higher variability.

## Relationship between bivalve abundance and seagrass biomass

```{r Biv_seagrass}
#| label: fig-Biv_seagrass_m2
#| fig-cap: Density of bivalves in relation with the total biomass of seagrass (sum of above ground and below ground biomass) for site H and L. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(tidyr)
library(vegan)
library(ggplot2)
library(ggiraph)
library(scales)
library(tidytext)  # for reorder_within / scale_y_reordered
library(glue)
library(brms)       # Bayesian models via Stan
library(posterior) 

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia","Scrobicularia",Species),
         Species = gsub("derussatus","decussatus", Species))

# --- Core/species universes ---
cores   <- df_bivalve %>% distinct(Core, Site)  # one site per core expected
species <- df_bivalve %>% distinct(Species)

# sanity check: duplicated core->site?
dup_cores <- cores %>% count(Core) %>% filter(n > 1)
if (nrow(dup_cores) > 0) {
  warning("Some cores map to multiple Sites; check 'cores' table.")
}

# --- Long community table with all Core x Species (zeros filled) ---
comm_long <- df_bivalve %>%
  group_by(Core, Species) %>%
  summarise(Abund = sum(Abondance, na.rm = TRUE), .groups = "drop") %>%
  complete(Core = cores$Core, Species = species$Species, fill = list(Abund = 0))

# --- Wide matrix for vegan ---
comm <- comm_long %>%
  pivot_wider(names_from = Species, values_from = Abund, values_fill = 0) %>%
  arrange(Core)

mat <- as.matrix(comm[, -1, drop = FALSE])

# --- Diversity metrics per core ---
H <- vegan::diversity(mat, index = "shannon")      # may be NA for all-zero rows
S <- vegan::specnumber(mat)
J <- ifelse(S > 0, H / log(S), 0)
N <- rowSums(mat)

# replace NA H with 0 for empty cores
H[is.na(H)] <- 0

shannon_by_core <- tibble(
  Core       = comm$Core,
  Shannon_H  = as.numeric(H),
  Richness_S = as.numeric(S),
  Evenness_J = as.numeric(J),
  N_total    = as.integer(N)*correction_factor
) %>%
  left_join(cores, by = "Core") 

# --- biomass (convert to g/m²) ---
dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A * correction_factor,
         B = B * correction_factor)


df_bivalve_seagrass <- shannon_by_core %>% 
left_join(dryweight, by = c("Core" = "Station")) %>% 
  mutate(overall_biomass = A+B)


# Data for the plot (remove NAs and build tooltips)
plot_df <- df_bivalve_seagrass %>%
  filter(is.finite(A), is.finite(Shannon_H)) %>%
  mutate(
    tooltip = glue(
      "<b>Core:</b> {Core}<br/>",
      "<b>Site:</b> {Site}<br/>",
      "<b>Shannon H′:</b> {round(Shannon_H, 3)}<br/>",
      "<b>Above-ground biomass A:</b> {number(A, accuracy = 0.1)} g/m²<br/>",
      "<b>Below-ground biomass B:</b> {number(B, accuracy = 0.1)} g/m²<br/>",
      "<b>Total biomass:</b> {number(overall_biomass, accuracy = 0.1)} g/m²"
    )
  )

# Plot (points are interactive, smooth shown per site)
p <- ggplot(plot_df, aes(x = overall_biomass, y = N_total , color = Site)) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = Core),
                         size = 3, alpha = 0.9) +
  geom_smooth(method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  # geom_smooth(data = plot_df, mapping = aes(x = A, y = Shannon_H),color = "black",method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  labs(
    title = "Bivales per m² vs Seagrass biomass",
    x = "Biomass of seagrass - Above and below - (g/m²)",
    y = "Individuals per m²"
  ) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal(base_size = 14) +
  scale_color_brewer(palette = "Set2") +   # or "Dark2" for stronger contrast

  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

g <- girafe(
  ggobj = p,
  width_svg = 9, height_svg = 6,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "single"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 5)
  )
)

g
```

@fig-Biv_seagrass_m2 illustrates the relationship between bivalve density (individuals per m²) and total seagrass biomass (above- and below-ground combined). Overall, bivalve density tends to be higher in site H compared to site L for a given seagrass biomass. In site H, values are more scattered, with several cores exceeding 700 individuals per m², whereas site L shows consistently lower densities, generally below 500 individuals per m². Both sites display a positive, though weak, association between biomass and bivalve density, as indicated by the fitted regression lines, but the wide confidence bands highlight considerable variability. This suggests that while higher seagrass biomass may provide more habitat structure and support larger bivalve populations, other local factors likely contribute to the observed heterogeneity.

## Relation between bivalve diversity and seagrass biomass 

@fig-Biv_seagrass_m2 shows the relationship between bivalve diversity and the total biomass of seagrass (above- and below-ground combined). Overall, no clear association was observed between these two variables, suggesting that bivalve diversity is primarily influenced by other environmental factors rather than seagrass biomass. The only exception was species richness in site L, where a weak positive relationship was apparent: cores with higher seagrass biomass tended to host a greater number of bivalve species.

```{r Biv_Diversity_seagrass}
#| label: fig-Biv_Indices_seagrass_m2
#| fig-cap: Diversity indices of bivalves in relation with the total biomass of seagrass (sum of above ground and below ground biomass) for site H and L. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(tidyr)
library(ggplot2)
library(ggiraph)
library(glue)
library(scales)

df_long <- df_bivalve_seagrass %>%
  dplyr::select(Core, Site, overall_biomass, Shannon_H, Evenness_J, Richness_S) %>%
  pivot_longer(
    cols = c(Shannon_H, Evenness_J, Richness_S),
    names_to = "Metric", values_to = "Value"
  ) %>%
  mutate(
    Metric_lab = recode(Metric,
                        Shannon_H = "Shannon H′",
                        Evenness_J = "Evenness J",
                        Richness_S = "Richness S"),
    tooltip = glue(
      "<b>Core:</b> {Core}<br/>",
      "<b>Site:</b> {Site}<br/>",
      "<b>{Metric_lab}:</b> {round(Value, 3)}<br/>",
      "<b>Total biomass:</b> {number(overall_biomass, accuracy = 0.1)} g/m²"
    )
  )

p_faceted <- ggplot(df_long, aes(x = overall_biomass, y = Value, color = Site)) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = Core), size = 3, alpha = 0.9) +
  geom_smooth(method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  facet_wrap(~ Metric_lab, scales = "free_y", ncol = 2) +
  labs(
    title = "Biodiversity indices vs seagrass biomass",
    x = "Biomass of seagrass - Above and below - (g/m²)", y = NULL
  ) +
  scale_x_continuous(labels = label_comma()) +
    scale_color_brewer(palette = "Set2") +   # or "Dark2" for stronger contrast
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

g_faceted <- girafe(
  ggobj = p_faceted,
  width_svg = 10, height_svg = 7,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "single"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 5)
  )
)

g_faceted  


```

## Focus on *Loripes orbiculatus*

@fig-Loripes_density compares the density of *Loripes orbiculatus* between sites H and L. Median densities were higher at site H (≈85 ind./m²) than at site L (0 ind./m²), with broader variability observed in H. The Kruskal–Wallis test confirmed a significant difference between sites ($\chi^2=9.83$, $p<0.05$), indicating that *L. orbiculatus* was substantially more abundant in H than in L.

```{r Loripes Abundance}
#| label: fig-Loripes_density
#| fig-cap: Density of *Loripes orbiculatus* depending on the site were it was sampled. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(ggplot2)
library(scales)
library(rstatix)   # kruskal_test, dunn_test, add_xy_position
library(ggpubr)

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_Loripes_Site <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia plana","S. plana",Species),
         Species = gsub("Ruditapes derussatus","R. decu.", Species),
         Species = gsub("Cerastoderma edule","C. edule", Species),
         Species = gsub("Loripes orbiculatus","L. orbi.", Species),
         Species = gsub("Macoma balthica","M. balthica", Species),
         Species = gsub("Abra tenuis","A. tenuis", Species),
         Species = gsub("Mya arenaria","M. arenaria", Species),
         Species = gsub("Ruditapes philippinarum","R. phili.", Species)) %>% 
  dplyr::filter(Species == "L. orbi.")

kw <- df_Loripes_Site %>% kruskal_test(Density ~ Site)

# Pairwise Dunn post-hoc with positions for plotting
dunn <- df_Loripes_Site %>%
  dunn_test(Density ~ Site, p.adjust.method = "BH") %>%
  add_xy_position(x = "Site")    # positions brackets above boxes

# --- Per-site counts for n labels ---
counts <- df_Loripes_Site %>%
  group_by(Site) %>%
  summarise(n = n(), y = max(Density, na.rm = TRUE) * 1.02, .groups = "drop")

# --- Base plot ---
p <- df_Loripes_Site %>% 
  ggplot(aes(x = Site, y = Density, fill = Site)) +
  geom_boxplot(width = 0.6, alpha = 0.6, color = "black", outlier.shape = NA) +
  # median tick mark (—) for readability
  stat_summary(fun = median, geom = "point", shape = 95, size = 7, color = "black") +
  # n labels
  geom_text(data = counts, aes(x = Site, y = 240, label = paste0("n = ", n)),
            vjust = 0, size = 5) +
  labs(
    title = "Loripes orbiculatus — Density by Site",
    subtitle = paste0("Kruskal–Wallis: χ² = ",
                      round(kw$statistic, 2),
                      ", df = ", kw$df,
                      ", p = ", format.pval(kw$p, digits = 3, eps = .001)),
    x = NULL,
    y = "Density (ind/m²)"
  ) +
  scale_y_continuous(labels = label_comma(), expand = expansion(mult = c(0.02, 0.12))) +
  scale_fill_brewer(palette = "Set2") +
  guides(fill = "none") +
  theme_minimal(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    axis.text.x = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

# --- Add pairwise significance brackets ---
p + stat_pvalue_manual(
  dunn,
  label = "p.adj.signif",  # significance stars (ns, *, **, ***)
  tip.length = 0.01,
  bracket.size = 1
)

```

@fig-Loripes_biomass illustrates the relationship between Loripes orbiculatus density and total seagrass biomass (above- and below-ground combined). Across all samples, a moderate positive correlation was detected (Spearman ρ = 0.501, p < 0.001, n = 59). At the site level, patterns differed: in site H, Loripes density increased significantly with seagrass biomass (ρ = 0.555, p = 0.0015; slope = 0.531), whereas in site L, the relationship was weaker and not statistically significant (ρ = 0.264, p = 0.175; slope = 0.247).

```{r  Loripes Abundance vs seagrass}
#| label: fig-Loripes_biomass
#| fig-cap: Density of *Loripes orbiculatus* depending on the total biomass of seagrass.
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"


df_Loripes_Site <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia plana","S. plana",Species),
         Species = gsub("Ruditapes derussatus","R. decu.", Species),
         Species = gsub("Cerastoderma edule","C. edule", Species),
         Species = gsub("Loripes orbiculatus","L. orbi.", Species),
         Species = gsub("Macoma balthica","M. balthica", Species),
         Species = gsub("Abra tenuis","A. tenuis", Species),
         Species = gsub("Mya arenaria","M. arenaria", Species),
         Species = gsub("Ruditapes philippinarum","R. phili.", Species)) %>% 
  dplyr::filter(Species == "L. orbi.") %>% 
  dplyr::select(Station = "Core", Site,Density)

df_Loripes_Seagrass <- dryweight %>% 
  left_join(df_Loripes_Site, by = "Station")



plot_df_Loripes <- df_Loripes_Seagrass %>%
  filter(is.finite(A), is.finite(Density)) %>%
  mutate(
    tooltip = glue(
      "<b>Core:</b> {Station}<br/>",
      "<b>Site:</b> {Site}<br/>",
      "<b>Above-ground biomass A:</b> {number(A, accuracy = 0.1)} g/m²<br/>",
      "<b>Below-ground biomass B:</b> {number(B, accuracy = 0.1)} g/m²<br/>",
      "<b>Abundance of Loripes:</b> {number(Density, accuracy = 0.1)} ind/m²"
    )
  )

plot_df_Loripes2 <- plot_df_Loripes %>%
  mutate(Biomass = A + B)

# overall Spearman correlation for the subtitle
ct_all <- cor.test(plot_df_Loripes2$Biomass, plot_df_Loripes2$Density, method = "spearman")
sub_txt <- glue("Overall Spearman ρ = {round(ct_all$estimate, 3)}, p = {signif(ct_all$p.value, 3)}, n = {nrow(plot_df_Loripes2)}")

# per-site stats (linear slope + Spearman)
stats_site <- plot_df_Loripes2 %>%
  group_by(Site) %>%
  summarise(
    n        = n(),
    rho      = suppressWarnings(cor(Biomass, Density, method = "spearman", use = "complete.obs")),
    p_rho    = suppressWarnings(cor.test(Biomass, Density, method = "spearman")$p.value),
    slope    = coef(lm(Density ~ Biomass))[2],
    .groups  = "drop"
  ) %>%
  mutate(
    label = glue("n = {n}\nρ = {round(rho,3)} (p = {signif(p_rho,3)})\nslope = {round(slope,3)}")
  )

# choose non-overlapping y positions for the labels
ymax <- max(plot_df_Loripes2$Density, na.rm = TRUE)
stats_site <- stats_site %>%
  arrange(desc(Site)) %>%                # ensures different offsets if only two sites
  mutate(x = -Inf,                       # top-left corner
         y = seq(ymax, ymax*0.7, length.out = n()))  # stagger vertically

# --- Plot with stats annotations ---
p <- ggplot(plot_df_Loripes2, aes(x = Biomass, y = Density, color = Site)) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = Station), size = 3, alpha = 0.9) +
  geom_smooth(method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  # per-site stats labels (static text on the interactive plot)
  geom_label(data = stats_site, aes(x = x, y = y, label = label, color = Site),
             inherit.aes = FALSE, show.legend = F,hjust = -0.05, vjust = 1, fill = "white", alpha = 0.8, label.size = 0.2) +
  labs(
    title = "Loripes per m² vs Seagrass biomass",
    subtitle = sub_txt,
    x = "Biomass of seagrass — Above + Below (g/m²)",
    y = "Individuals of Loripes per m²"
  ) +
  scale_x_continuous(labels = scales::label_comma()) +
  theme_minimal(base_size = 14) +
  scale_color_brewer(palette = "Set2") +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

g <- girafe(
  ggobj = p,
  width_svg = 9, height_svg = 6,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "single"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 5)
  )
)

g

```

**Taken together, these results indicate that *L. orbiculatus* is both more abundant and more closely associated with seagrass biomass in site H, where meadows have maintained consistently high cover over the past 40 years. In contrast, at site L, where seagrass cover has been more variable through time, *Loripes* populations remain sparse and show no clear link with biomass. This suggests that long-term meadow stability may be a key factor supporting dense and persistent *L. orbiculatus* populations.**

```{r zip outputs}
#| echo: false
#| message: false
#| warning: false
#| cache: false
#| eval: true


# ---- settings ----
folder_to_zip <- "data"   # directory whose contents you want to archive
zip_file      <- "Output/Data_REWRITE_Bourgneuf_bay.zip"

# ---- create the zip ----
# list all files (recursive = TRUE grabs sub-folders too; set FALSE if you only
# want the top-level files)
files <- list.files(folder_to_zip, recursive = TRUE, full.names = TRUE)

# make sure you’re in the folder so the archive has relative paths, not full paths

utils::zip(zipfile = zip_file, files = files)
```
