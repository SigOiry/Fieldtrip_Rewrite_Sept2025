---
title: "Field Campaign of Bourgneuf Bay 2025 - REWRITE"
author: "Simon Oiry"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

::: {style="text-align: center; margin-top: 20px;"}
<button onclick="window.open(&#39;https://github.com/SigOiry/Fieldtrip_Rewrite_Sept2025/raw/refs/heads/main/Output/Data_REWRITE_Bourgneuf_bay.zip&#39;, &#39;_blank&#39;);" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">

Download all the data of that campaign
</button>
:::

# Field trip organisation

The summer field campaign in Bourgneuf Bay took place on September 11th,
2025, at the Barbâtre meadow. Low tide occurred at 14:20 local time,
with a tidal range of 4.75 m. We arrived on site around 11:00. Two
distinct sampling areas were selected based on the historical
consistency of meadow density over the past 40 years. One area, where
the meadow has consistently shown more than 50% seagrass cover every
year for the last 40 years, was selected (Zone H), as well as an area
where meadow cover has been highly inconsistent over the same period
(Zone L). In each zone, 30 cores were collected, covering a gradient of
seagrass cover from low (SPC \< 20%) to high (SPC \> 80%). Each core was
20 cm deep to harvest seagrass leaves, rhizomes, and associated fauna.


## What has been done in each area ?

**Zone L :**

-   Photo quadrat

-   Coring

-   Above and Bellow ground biomass (Dry weight)

-   Bivalves Diversity and Density

-   Sediment Sampling

**Zone H :**

-   Photo quadrat

-   Coring

-   Above and Bellow ground biomass (Dry weight)

-   Bivalves Diversity and Density

-   Carbon Estimation

-   Hyperspectral measurments

-   Sediment Sampling

# Above Ground vs Below Ground biomass

```{r image patchwork}
#| echo: false
#| error: false
#| message: false
#| warning: false
#| eval: false

# install.packages(c("magick", "tidyverse"))  # if needed
library(magick)
library(tidyverse)

library(magick)
library(tidyverse)

make_image_grid_tidy <- function(
  img_paths,
  ncol = 10,
  cell_size = 320,
  font_size = 50,
  outfile  = "grid.png",
  pad = 10,
  bg = "white",
  label_color = "white",
  label_box   = "#00000080",
  letterbox = FALSE
) {
  stopifnot(length(img_paths) > 0)

  # helper: square & label one image
  square_and_label <- function(path, name) {
    img <- image_read(path)
    img <- if (letterbox) {
      img |>
        image_resize(paste0(cell_size, "x", cell_size)) |>
        image_extent(paste0(cell_size, "x", cell_size),
                     gravity = "center", color = bg)
    } else {
      img |>
        image_resize(paste0(cell_size, "x", cell_size, "^")) |>
        image_crop(paste0(cell_size, "x", cell_size, "+0+0"))
    }
    image_annotate(
      img, text = name, gravity = "southeast",
      size = font_size, color = label_color, boxcolor = label_box,
      location = paste0("+", pad, "+", pad)
    )
  }

  # tiles
  tiles_tbl <- tibble(path = img_paths) |>
    mutate(name = basename(path),
           img  = map2(path, name, square_and_label))

  # pad to complete last row
  n <- nrow(tiles_tbl)
  nrow_g <- ceiling(n / ncol)
  total  <- nrow_g * ncol
  if (total > n) {
    blanks <- tibble(
      path = NA_character_,
      name = "",
      img  = map(seq_len(total - n), ~ image_blank(cell_size, cell_size, color = bg))
    )
    tiles_tbl <- bind_rows(tiles_tbl, blanks)
  }

  # row/col indices
  tiles_tbl <- tiles_tbl |>
    mutate(idx = row_number(),
           row = ceiling(idx / ncol),
           col = ((idx - 1) %% ncol) + 1) |>
    arrange(row, col)

  # build each row (horizontally), then stack rows (vertically)
  row_imgs <- tiles_tbl |>
    group_split(row, keep = FALSE) |>
    map(~ {
      imgs <- .x$img
      image_append(image_join(imgs), stack = FALSE)
    })

  final <- image_append(image_join(row_imgs), stack = TRUE)

  image_write(final, path = outfile)
  message("Wrote: ", normalizePath(outfile))
  invisible(outfile)
}

files <- list.files("data/imgs", pattern = "\\.(jpe?g|tif?f)$", full.names = TRUE)
make_image_grid_tidy(files, ncol = 10, cell_size = 800, outfile = "data/imgs/grid.png")

```

```{r image patchwork}
#| echo: false
#| error: false
#| message: false
#| warning: false
#| fig-width: 10
#| fig-height: 10
#| out-width: "95%"
#| label: fig-images
#| fig-cap: Patchwork of the 60 photo-quadrat corresponding to the 60 cores performed during the Rewrite field campaign of Bourgneuf Bay. From top-left to bottom right H_01 to H_30 followed by L_01 to L_30.

htmltools::HTML('
<figure>
  <img id="gridimg" src="data/imgs/grid.png" alt="Patchwork of the 60 photo-quadrats" style="max-width:95%; cursor:grab; touch-action:none;" />
</figure>

<link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/@panzoom/panzoom/dist/panzoom.min.js">
<script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom/dist/panzoom.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
  const el = document.getElementById("gridimg");
  const pz = Panzoom(el, { maxScale: 8, contain: "outside" });
  el.parentElement.addEventListener("wheel", pz.zoomWithWheel);
});
</script>
')

```

The samples were sorted to separate seagrass above-ground biomass (AGB) from below-ground biomass (BGB), and bivalves were counted and identified. After sorting, the leaf and rhizome fractions were dried for 48 h at 60 °C in a drying oven and then weighed on a precision balance to obtain dry mass for each core. @fig-Above_Below shows the relationship between BGB and AGB for all 60 cores collected in the field. 
```{r Plot above vs below}
#| label: fig-Above_Below
#| fig-cap: Relationship between the above and below ground biomass
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(ggplot2)
library(ggiraph)
library(dplyr)
library(scales)
library(tidyverse)

Core_Diameter <- 15 ### diameter of the core used for sampling (in cm)

core_area <- pi*((Core_Diameter/2)^2) #### Area of the core

correction_factor <- (100*100)/core_area #### Correction factor to convert the dry weight to g/m²

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A*correction_factor,
         B = B*correction_factor, 
         Area = substr(Station,1,1))### Convert the dryweight to be in g/m²

lm<- lm(dryweight$B ~ dryweight$A)$coefficients

p <- ggplot(
  dryweight,
  aes(x = A, y = B)
) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.1, linewidth = 1,
    color = "black") +
  geom_point_interactive(
    aes(color = Area,
      tooltip = paste0(
        "Sample: ", Station, "\n",
        "Above ground: ", number(A, accuracy = 0.01), " g/m²\n",
        "Below ground: ", number(B, accuracy = 0.001), " g/m²\n"
      )
    ),
    alpha = 0.7, size = 2
  ) +
  scale_color_manual(values = c(
    "H" = "#E69F00",   # Orange
    "L" = "#0072B2"    # Blue
  ))+
  labs(
    x = "Above ground biomass (g/m²)",
    y = "Below ground biomass  (g/m²)",
    color = "Area"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = c(0.02, 0.98),
    legend.justification = c(0, 1),
    legend.background = element_rect(fill = scales::alpha("white", 0.6), color = "grey80"),
    legend.title = element_text(size = 13),
    legend.text  = element_text(size = 12),
    axis.title   = element_text(size = 14, face = "bold"),
    axis.text    = element_text(size = 12),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 7, height_svg = 5,
  options = list(
    opts_tooltip(opacity = .95),
    opts_hover(css = "r:4pt; stroke-width: 2;")
  )
)

```

The relationship between the below ground and above ground biomass of *Zostera noltei* in Bourgneuf Bay can be describe as follow:

$$
Below_{Ground} = 0.64 * Above_{Ground} + 10.04
$$

Site L and Site H have a similar relationship between those two variables (@fig-Above_Below).

# Hyperspectral signature zone H

Only in Zone H, before coring, a hyperspectral signature of the sample
was taken using an ASD Fieldspec HandHeld 2. The instrument was
calibrated in the field for reflectance acquisition using a Spectralon
with a 99% reflective Lambertian surface (No radiance measurement has
been done).

```{r Hyperspectral signature}
#| label: fig-hyperspectral
#| fig-cap: Hyperspectrale signature of each core of the Area H. Left plot show the raw reflectance signature while the right plot shows the min-max standardised signatures. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(ggplot2)
library(ggiraph)
library(scales)
library(dplyr)
library(tidyverse)
library(plotly)

df_sp <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = T),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  dplyr::filter(Wavelength > 400,
                Wavelength < 900) %>% 
  group_by(spectra) %>% 
  mutate(ref_std = (ref_mean - min(ref_mean))/(max(ref_mean)-min(ref_mean))) %>% 
  dplyr::select(-sd) %>% 
  pivot_longer(c(ref_mean,ref_std), names_to = "Proc",values_to = "value") %>% 
  ungroup() %>% 
  mutate(Proc = case_when(Proc == "ref_mean" ~ "Raw",
                          T ~ "Standardised"))


# df_sp already created above

# make spectra a nicely ordered factor (optional)
df_sp <- df_sp %>%
  arrange(spectra, Wavelength) %>%
  mutate(spectra = factor(spectra, levels = sort(unique(spectra))))

p <- ggplot(
  df_sp,
  aes(x = Wavelength, y = value, color = spectra, group = spectra)
) +
  facet_wrap(~Proc, scales = "free")+
  # interactive line: tooltip shows spectra; data_id enables hover styling
  geom_line_interactive(
    aes(tooltip = paste0("Spectra: ", spectra),
        data_id  = spectra),
    linewidth = 0.9, alpha = 0.9, show.legend = F
  ) +
  scale_color_viridis_d(option = "viridis", end = 0.95) +
  scale_y_continuous(labels = label_percent(accuracy = 1)) +
  labs(
    x = "Wavelength (nm)",
    y = "Reflectance",
    color = "Spectra"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11),
    axis.title   = element_text(size = 13, face = "bold"),
    axis.text    = element_text(size = 11),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 7, height_svg = 5,
  options = list(
    # thicken the line you hover, fade others
    opts_hover(css = "stroke-width:2.5px;"),
    opts_hover_inv(css = "opacity:0.25;"),
    # nicer tooltip
    opts_tooltip(opacity = .95, css = "padding:6px; font-size:12px;")
  )
)

```

@fig-hyperspectral shows the hyperspectral signature of all the cores of the area H. Spectra are showing differente level of reflectance, with core H_04 having a relatively strong overall reflectance, with an small absorption peak around 665 nm due to the presence of chlorophyll-a. On the other hand the spectra H_30 is showing a lower overall reflectance, with really low reflectance in the visible and a strong absorption peak of chlorophyll-a around 665nm.

## About the reflectance anomaly around 760 nm. 

An unexpected reflectance feature can be observed around 761 nm in most of the spectra (@fig-hyperspectral). This feature appears as a positive anomaly in some cases, such as H_04 or H_03, or as a negative anomaly, as in H_02 or H_19. The most likely explanation is an instrumental artifact, for example related to calibration issues of the ASD spectroradiometer. Nevertheless, it is worth noting that at 761 nm vegetation can also produce a narrow reflectance peak due to sunlight-induced chlorophyll fluorescence (SIF). This fluorescence signal arises from the broad chlorophyll a emission around 740 nm that partly fills the atmospheric O₂ absorption band, and has been documented both in terrestrial and aquatic vegetation ([Lu et al. 2016](https://doi.org/10.1002/2016JC011797), [Meroni & Colombo, 2006](https://doi.org/10.1016/j.rse.2006.03.016)). 

To investigate the origin of this feature, the Fluorescence Line Height (FLH;[Lu et al. 2016](https://doi.org/10.1002/2016JC011797)) will be calculated. 

$$
\mathrm{FLH}(761)
= R_{rs}(761)
- \left[
\frac{769-761}{769-757}
\big(R_{rs}(757)-R_{rs}(769)\big)
+ R_{rs}(769)
\right]
$$

The FLH values will be compared with NDVI, as proxy of the biomass, with the green leaf index proxy of the greeness of seagrass leaves as well as with the amount of time the ASD had been operating at the moment of spectrum acquisition.

@fig-LH_Index is showing the ralationship between the FLH, measuring the height of the peak visible at 761 nm, and the NDVI and the GLI. No relationship between the size of the anomaly and those radiometric indices can been seen from the data acquired on site H. No matter the biomass, and no matter the greenness of leaves, the peak at 761 nm can be more or less pronounced.

```{r LH vs NDVI}
#| label: fig-LH_Index
#| fig-cap: Relationship between the Fluorescence Line Height (FLH) and radiometric indices. The Normalised difference vegetation index is a proxy of the biomass while the Green Leaf Index is a proxy of leaves greenness. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(purrr)

df_sp <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1,3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = T),
          sd = sd(ref)) 


# --- Target wavelengths ---
l1 <- 757; l2 <- 761; l3 <- 769
wl_red <- 670; wl_nir <- 800
wl_green <- 550; wl_blue <- 450

# --- Indices per spectrum (with linear interpolation) ---
indices <- df_sp %>% 
  arrange(spectra, Wavelength) %>%
  group_by(spectra) %>%
  summarise(
    R757  = approx(Wavelength, ref_mean, xout = l1,      rule = 2)$y,
    R761  = approx(Wavelength, ref_mean, xout = l2,      rule = 2)$y,
    R769  = approx(Wavelength, ref_mean, xout = l3,      rule = 2)$y,
    Rred  = approx(Wavelength, ref_mean, xout = wl_red,  rule = 2)$y,
    Rnir  = approx(Wavelength, ref_mean, xout = wl_nir,  rule = 2)$y,
    Rgrn  = approx(Wavelength, ref_mean, xout = wl_green,rule = 2)$y,
    Rblue = approx(Wavelength, ref_mean, xout = wl_blue, rule = 2)$y,
    .groups = "drop"
  ) %>%
  mutate(
    # FLH at 761 nm
    FLH  = R761 - ( ((l3 - l2) / (l3 - l1)) * (R757 - R769) + R769 ),
    # NDVI (NIR 800 / Red 670)
    NDVI = (Rnir - Rred) / (Rnir + Rred),
    # GLI (Green Leaf Index)
    GLI  = (2*Rgrn - Rred - Rblue) / (2*Rgrn + Rred + Rblue)
  )

# --- Long form for faceting: NDVI vs FLH and GLI vs FLH ---
plot_df <- indices %>%
  select(spectra, FLH, NDVI, GLI) %>%
  tidyr::pivot_longer(c(NDVI, GLI), names_to = "Index", values_to = "Value") %>%
  mutate(Index = factor(Index, levels = c("NDVI","GLI"))) %>%
  arrange(Index, FLH)

# --- Interactive, facetted plot ---
p <- ggplot(plot_df, aes(x = FLH, y = Value)) +
  geom_smooth(method = "lm", formula = y ~ x, se = TRUE, linewidth = 1, color = "grey30") +
  geom_point_interactive(
    aes(
      tooltip = paste0(
        "Sample: ", spectra, "\n",
        "FLH: ", number(FLH, accuracy = 0.00001), "\n",
        Index, ": ", number(Value, accuracy = 0.003)
      ),
      data_id = spectra
    ),
    size = 2.4, alpha = 0.85
  ) +
  facet_wrap(~ Index, ncol = 2, scales = "free") +
  labs(
    title = "Relationships of NDVI and GLI with FLH",
    x = "FLH",
    y = "Index value"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    strip.text = element_text(size = 13, face = "bold"),
    axis.title = element_text(size = 13, face = "bold"),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 9, height_svg = 5,
  options = list(
    opts_tooltip(css = "background:rgba(0,0,0,.9); color:#fff; padding:6px 8px; border-radius:4px;"),
    opts_hover(css = "r:4pt; stroke:#222; stroke-width:1.5px;"),
    opts_hover_inv(css = "opacity:0.25;")
  )
)
```

To estimate, for each spectrum, how long the instrument had been running at the time of acquisition, we extracted the capture time of the corresponding photo-quadrat from the images’ EXIF metadata. Because the photo-quadrats were taken a few minutes before the hyperspectral measurements, their timestamps provide a close proxy for the acquisition time; aligning these timestamps with the instrument start time yields the elapsed operating time for each spectrum. Sample H_01 was acquired first. By convention, we set its instrument run time to 0 (min), and the run time for all subsequent samples is expressed relative to H_01—that is, as the difference between each sample’s acquisition timestamp and that of H_01.

```{r Running_Time vs FLH}
#| label: fig-LH_runningtime
#| fig-cap: Relationship between the Fluorescence Line Height (FLH) and the amount of time the ASD Specfield Handheld 2 has been running. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| cache: true
#| out-width: "95%"

library(exiftoolr)
library(tidyverse)

files <- list.files("data/imgs/RAW_H", pattern = "\\.(jpe?g|tif?f)$", full.names = TRUE)

j <- exif_read(files[1])$ModifyDate


df_acquisition <- map_df(files, function(f) {
  x <- exif_read(f, tags = "ModifyDate")
  tibble(
    file               = f,
    AcquisitionDate    = x$ModifyDate
  )
}) %>% 
  mutate(AcquisitionDate = as.POSIXct(AcquisitionDate, format = "%Y:%m:%d %H:%M:%OS"),
         filename = gsub(".*/","",file),
         sample = substr(filename,1,4))

initial_date <- df_acquisition %>% 
  dplyr::filter(sample == "H_01") %>% 
  pull(AcquisitionDate)

df_acquisition <- df_acquisition %>% 
  mutate(running_time = AcquisitionDate - initial_date) %>% 
  left_join(indices %>%
              select(spectra, FLH, NDVI, GLI) %>% 
              mutate(spectra = gsub("H","H_",spectra)), by = c("sample" = "spectra"))

p <- ggplot(df_acquisition, aes(x = running_time, y = FLH)) +
  geom_smooth(method = "lm", formula = y ~ x, se = TRUE, linewidth = 1, color = "grey30") +
  geom_point_interactive(
    aes(tooltip = sample, data_id = sample),
    size = 2.6, alpha = 0.85
  ) +
  labs(
    title = "FLH vs. instrument running time",
    x = "Instrument running time (seconds)",
    y = "FLH"
  ) +
  ylim(c(-0.004,0.008))+
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    strip.text = element_text(size = 13, face = "bold"),
    axis.title = element_text(size = 13, face = "bold"),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 9, height_svg = 5,
  options = list(
    opts_tooltip(css = "background:rgba(0,0,0,.9); color:#fff; padding:6px 8px; border-radius:4px;"),
    opts_hover(css = "r:4pt; stroke:#222; stroke-width:1.5px;"),
    opts_hover_inv(css = "opacity:0.25;")
  )
)

```

@fig-LH_runningtime shows the relationship between ASD run time and the fluorescence line height at 761 nm (FLH). Sample H_01 was acquired immediately after startup (T0), and the last sample in the sequence, H_08, was collected 7,316 s (≈ 122 min) after T0. A negative linear trend can be seen (grey 95% CI shown): FLH values are highest at the beginning of the session and decline as the instrument continues to run, with several late measurements approaching zero or slightly negative values.

## Radiometric indices vs Biomass

```{r find the index the most linked with above ground biomass}
#| echo: false
#| error: false
#| message: false
#| warning: false
#| eval: false

library(dplyr)
library(tidyr)
library(purrr)
library(broom)


Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A * correction_factor,
         B = B * correction_factor)
# ---- Step 1: Define helper for index calculation ----
compute_indices <- function(df, 
                            wl_red = 670, wl_nir = 800, 
                            wl_blue = 450, wl_green = 550, 
                            wl_rededge = 705, wl_445 = 445, wl_750 = 750) {
  
  # interpolate reflectances
  red   <- approx(df$Wavelength, df$ref_mean, xout = wl_red)$y
  nir   <- approx(df$Wavelength, df$ref_mean, xout = wl_nir)$y
  blue  <- approx(df$Wavelength, df$ref_mean, xout = wl_blue)$y
  green <- approx(df$Wavelength, df$ref_mean, xout = wl_green)$y
  re    <- approx(df$Wavelength, df$ref_mean, xout = wl_rededge)$y
  r445  <- approx(df$Wavelength, df$ref_mean, xout = wl_445)$y
  r750  <- approx(df$Wavelength, df$ref_mean, xout = wl_750)$y
  
  tibble(
    # Classic indices
    NDVI   = (nir - red) / (nir + red),
    SR     = nir / red,
    MSR    = (nir/red - 1) / sqrt(nir/red + 1),
    DVI    = nir - red,
    RVI    = red / nir,
    
    # Soil/structure corrected
    SAVI   = 1.5 * (nir - red) / (nir + red + 0.5),
    OSAVI  = 1.16 * (nir - red) / (nir + red + 0.16),
    TSAVI  = (0.08 * (nir - 0.5*red - 0.08)) / (red + 0.5*nir + 0.08),
    
    # Atmosphere resistant
    EVI    = 2.5 * (nir - red) / (nir + 6*red - 7.5*blue + 1),
    EVI2   = 2.5 * (nir - red) / (nir + 2.4*red + 1),
    
    # Greenness indices
    GNDVI  = (nir - green) / (nir + green),
    VARI   = (green - red) / (green + red - blue),
    CIG    = (nir / green) - 1,   # chlorophyll index green
    CIRE   = (nir / re) - 1,      # chlorophyll index red edge
    
    # Red edge indices
    NDRE   = (nir - re) / (nir + re),
    
    # Other spectral indices
    MTVI2  = (1.5 * (1.2*(nir - green) - 2.5*(red - green))) / sqrt((2*nir + 1)^2 - (6*nir - 5*sqrt(red)) - 0.5),
    MCARI  = ((re - red) - 0.2*(re - green)) * (re/red),
    
    # Pigment indices
    PRI    = (green - re) / (green + re),
    SIPI   = (nir - blue) / (nir - red),
    
    # Simple phenology-related
    NDWI   = (nir - green) / (nir + green),   # often used for water content
    ARVI   = (nir - (2*red - blue)) / (nir + (2*red - blue)),
    
    # --- New index ---
    mND705 = (r750 - re) / (r750 + re - 2 * r445)
  )
}



# ---- Step 2: Apply to each spectrum ----
# Suppose `spectra_df` has columns: Spectra, Wavelength, Reflectance
# and `biomass_df` has columns: Spectra, A (above-ground biomass)

indices_df <- df_sp %>%
  group_by(spectra) %>%
  group_modify(~ compute_indices(.x)) %>%
  ungroup()

# ---- Step 3: Join with biomass ----
data_all <- indices_df %>%
  mutate(spectra = gsub("H","H_",spectra)) %>% 
  left_join(dryweight, by = c("spectra" = "Station"))


# ---- Step 4: Correlate each index with biomass ----
results <- data_all %>%
  pivot_longer(cols = -c(spectra,A,B), names_to = "Index", values_to = "Value") %>%
  group_by(Index) %>%
  summarise(
    model = list(lm((A) ~ Value, data = cur_data())),
    .groups = "drop"
  ) %>%
  mutate(
    glance = map(model, broom::glance)
  ) %>%
  unnest(glance) %>%
  arrange(desc(r.squared)) %>%
  select(Index, r.squared, adj.r.squared, p.value)

print(results)


```

From those spectral signatures, a range of spectral indices were tested to identify the one with the strongest relationship to above-ground biomass. All the indices listed below were evaluated, but only the results for the best-performing index and the NDVI are shown. 

$$
\begin{aligned}
\text{NDVI}   &= \frac{R_{NIR} - R_{Red}}{R_{NIR} + R_{Red}}       &\quad
\text{GNDVI}  &= \frac{R_{NIR} - R_{Green}}{R_{NIR} + R_{Green}} \\[6pt]
\text{SR}     &= \frac{R_{NIR}}{R_{Red}}                           &\quad
\text{VARI}   &= \frac{R_{Green} - R_{Red}}{R_{Green} + R_{Red} - R_{Blue}} \\[6pt]
\text{MSR}    &= \frac{\tfrac{R_{NIR}}{R_{Red}} - 1}{\sqrt{\tfrac{R_{NIR}}{R_{Red}} + 1}} &\quad
\text{CIG}    &= \frac{R_{NIR}}{R_{Green}} - 1 \\[6pt]
\text{DVI}    &= R_{NIR} - R_{Red}                                  &\quad
\text{CIRE}   &= \frac{R_{NIR}}{R_{RE}} - 1 \\[6pt]
\text{RVI}    &= \frac{R_{Red}}{R_{NIR}}                            &\quad
\text{NDRE}   &= \frac{R_{NIR} - R_{RE}}{R_{NIR} + R_{RE}} \\[6pt]
\text{SAVI}   &= \frac{1.5 \, (R_{NIR} - R_{Red})}{R_{NIR} + R_{Red} + 0.5} &\quad
\text{MTVI2}  &= \frac{1.5 \left[ 1.2(R_{NIR} - R_{Green}) - 2.5(R_{Red} - R_{Green}) \right]}
{\sqrt{(2R_{NIR}+1)^2 - (6R_{NIR} - 5\sqrt{R_{Red}}) - 0.5}} \\[6pt]
\text{OSAVI}  &= \frac{1.16 \, (R_{NIR} - R_{Red})}{R_{NIR} + R_{Red} + 0.16} &\quad
\text{MCARI}  &= \left[(R_{RE} - R_{Red}) - 0.2(R_{RE} - R_{Green})\right] \frac{R_{RE}}{R_{Red}} \\[6pt]
\text{TSAVI}  &= \frac{0.08 \, (R_{NIR} - 0.5R_{Red} - 0.08)}{R_{Red} + 0.5R_{NIR} + 0.08} &\quad
\text{PRI}    &= \frac{R_{Green} - R_{RE}}{R_{Green} + R_{RE}} \\[6pt]
\text{EVI}    &= \frac{2.5 \, (R_{NIR} - R_{Red})}{R_{NIR} + 6R_{Red} - 7.5R_{Blue} + 1} &\quad
\text{SIPI}   &= \frac{R_{NIR} - R_{Blue}}{R_{NIR} - R_{Red}} \\[6pt]
\text{EVI2}   &= \frac{2.5 \, (R_{NIR} - R_{Red})}{R_{NIR} + 2.4R_{Red} + 1} &\quad
\text{NDWI}   &= \frac{R_{NIR} - R_{Green}}{R_{NIR} + R_{Green}} \\[6pt]
\text{mND705} &= \frac{R_{750} - R_{705}}{R_{750} + R_{705} - 2R_{445}} &\quad &
\end{aligned}
$$

The index with the highest R² against above-ground biomass is NDRE. NDRE is analogous to NDVI but replaces the red band (~665 nm) with a red-edge band (typically ~705 nm):
The advantage is reduced saturation at high biomass. Around 665 nm, chlorophyll-a absorption quickly reaches an asymptote, so reflectance in the red band changes little as biomass increases and NDVI tends to plateau. In the red-edge region, however, reflectance remains sensitive: as biomass/chlorophyll increases, reflectance near ~705 nm continues to decrease (with a concomitant shift of the red-edge to longer wavelengths). Consequently, NDRE preserves sensitivity in dense canopies and correlates more strongly with biomass than NDVI, resulting with an R² square slightly higher than for the NDVI (R²_NDVI = 0.65, R²_NDRE = 0.67)... -_-'

```{r Plot NDVI dryweight}
#| label: fig-hyperspectral_dryweight
#| fig-cap: Relationship between the NDRE, the NDVI and the dry weight of seagrasses measured in area H 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(tidyr)
library(ggplot2)
library(ggiraph)
library(scales)

# --- wavelengths ---
wl_red  <- 670   # NDVI red
wl_nir  <- 750   # NDVI/NDRE NIR
wl_re   <- 705   # red-edge for NDRE

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

# --- spectra (as you had) ---
df_sp <- read.delim("data/spectra/20250911_Bourgneuf_H_stations_reflectance.txt") %>% 
  pivot_longer(-Wavelength, names_to = "spectra", values_to = "ref") %>% 
  mutate(spectra = substr(spectra, 1, 3)) %>% 
  group_by(Wavelength, spectra) %>% 
  reframe(ref_mean = mean(ref, na.rm = TRUE),
          sd = sd(ref)) %>% 
  ungroup() %>% 
  mutate(spectra = gsub("H","H_", spectra))

# --- NDVI + NDRE per spectrum (linear interpolation to target λ) ---
indices <- df_sp %>% 
  arrange(spectra, Wavelength) %>%
  group_by(spectra) %>%
  summarise(
    red = approx(Wavelength, ref_mean, xout = wl_red, rule = 2)$y,
    re  = approx(Wavelength, ref_mean, xout = wl_re,  rule = 2)$y,
    nir = approx(Wavelength, ref_mean, xout = wl_nir, rule = 2)$y,
    NDVI = (nir - red) / (nir + red),
    NDRE = (nir - re)  / (nir + re),
    .groups = "drop"
  )

# --- biomass (convert to g/m²) ---
dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A * correction_factor,
         B = B * correction_factor)

# --- prepare data for plotting (Above-ground only) ---
plot_df <- indices %>% 
  left_join(dryweight, by = c("spectra" = "Station")) %>% 
  transmute(
    spectra,
    Biomass = A,
    NDVI, NDRE
  ) %>% 
  pivot_longer(c(NDVI, NDRE), names_to = "Index", values_to = "Value") %>% 
  mutate(Index = factor(Index, levels = c("NDVI","NDRE"))) %>%
  arrange(Index, Biomass)

# --- interactive two-panel plot (NDVI left, NDRE right) ---
p <- ggplot(
  plot_df,
  aes(x = Biomass, y = Value)
) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.12, linewidth = 1, color = "grey30") +
  geom_point_interactive(
    aes(
      tooltip = paste0(
        "Sample: ", spectra, "\n",
        "Biomass: ", number(Biomass, accuracy = 0.01), " g/m²\n",
        Index, ": ", number(Value, accuracy = 0.003)
      ),
      data_id = spectra
    ),
    size = 2, alpha = 0.8
  ) +
  facet_wrap(~ Index, ncol = 2, scales = "free") +   # NDVI (left) and NDRE (right)
  labs(
    x = "Above-ground biomass (g/m²)",
    y = "Index value"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    strip.text = element_text(size = 13, face = "bold"),
    axis.title = element_text(size = 14, face = "bold"),
    panel.grid.minor = element_blank()
  )

girafe(
  ggobj = p,
  width_svg = 9, height_svg = 5,
  options = list(
    opts_tooltip(opacity = .95),
    opts_hover(css = "r:4pt; stroke-width: 2;"),
    opts_hover_inv(css = "opacity:0.25;")
  )
)

```

```{r leafletmap}
#| fig-cap: Map of Bourgneuf Bay Sampling site
#| echo: false
#| error: false
#| message: false
#| eval: false
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(leaflet)
library(sf)
library(leafem)
library(leaflet.extras2)
library(terra)

# folder structure: ./www/imgs/...
img_list <- list.files("data/imgs", recursive = TRUE, full.names = TRUE, pattern = "\\.jpg$") %>%
  tibble(path = .) %>%
  mutate(filename = basename(path),
         station  = substr(filename, 1, 4),
         url      = paste0(file.path("imgs", filename)))

Points <- sf::st_read("data/shp/Core_Location/Points.shp", quiet = TRUE) %>%
  left_join(img_list, by = c("Name" = "station")) %>%
  filter(!is.na(url))

leaflet() %>%
  setView(lng = -2.176695, lat = 46.962474, zoom = 15) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery",
                   options = providerTileOptions(minZoom = 8, maxZoom = 20)) %>%
  addCircleMarkers(
    data = Points, radius = 2, color = "lightgreen", fillColor = "lightgreen", fillOpacity = 0.8,
    group = "Coring stations",
    popup = ~sprintf("<img src='%s' width='400'/>", url),
    popupOptions = popupOptions(
    maxWidth  = 450,    # Maximum width of the popup
    minWidth  = 100,    # Minimum width of the popup
    maxHeight = 600)
  ) %>%
  addLayersControl(overlayGroups = "Coring stations",
                   options = layersControlOptions(collapsed = FALSE))


# htmlwidgets::saveWidget(plot_S2, file="maps/map_Bathy_Quiberon.html", selfcontained = F)

```

# Bivalve diversity & spatial distribution

The student quantified the density of all bivalve species present in the sediment while sorting each core, and all taxonomic identifications were subsequently verified by a taxonomist.

```{r Bivalve analysis}
#| label: fig-BivDensity
#| fig-cap: Average density of each bivalve specie across all 60 cores (Left) and Percentage of core were each species were found (Right). 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(tidyverse)
library(readxl)
library(patchwork)

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia plana","S. plana",Species),
         Species = gsub("Ruditapes derussatus","R. decu.", Species),
         Species = gsub("Cerastoderma edule","C. edule", Species),
         Species = gsub("Loripes orbiculatus","L. orbi.", Species),
         Species = gsub("Macoma balthica","M. balthica", Species),
         Species = gsub("Abra tenuis","A. tenuis", Species),
         Species = gsub("Mya arenaria","M. arenaria", Species),
         Species = gsub("Ruditapes philippinarum","R. phili.", Species))

density_by_specie_ci <- df_bivalve %>% 
  group_by(Species) %>% 
  summarise(
    n = sum(!is.na(Density)),
    mean_density = mean(Density, na.rm = TRUE),
    sd = sd(Density, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  mutate(
    sd = if_else(is.na(sd), 0, sd),
    se = sd / sqrt(pmax(n, 1)),
    ci95 = qt(0.975, df = pmax(n - 1, 1)) * se
  )

species_levels <- density_by_specie_ci %>%
  arrange(mean_density) %>%
  pull(Species)

# Rebuild your first plot as an object (p1) using fixed factor levels
p1 <- ggplot(density_by_specie_ci,
             aes(x = factor(Species, levels = species_levels), y = mean_density)) +
  geom_col(width = 0.7, fill = "grey70") +
  geom_errorbar(aes(ymin = mean_density - ci95, ymax = mean_density + ci95),
                width = 0.2, linewidth = 0.6) +
  coord_flip() +
  labs(
    title = "Average Density by Species (±95% CI)",
    x = "Species",
    y = "Mean Density (ind/m²)"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.x = element_text(margin = margin(t = 8)),
    axis.title.y = element_text(margin = margin(r = 8))
  )

# --- Presence (% of cores) per species ---
total_cores <- dplyr::n_distinct(df_bivalve$Core)

presence_by_specie <- df_bivalve %>%
  filter(!is.na(Abondance), Abondance > 0) %>%         # presence if count > 0
  group_by(Species) %>%
  summarise(cores_present = n_distinct(Core), .groups = "drop") %>%
  mutate(
    percent_cores = 100 * cores_present / total_cores
  )

p2 <- ggplot(presence_by_specie,
             aes(x = factor(Species, levels = species_levels),
                 y = percent_cores)) +
  geom_col(width = 0.7, fill = "grey70") +
  coord_flip() +
  labs(
    title = "Occurrence",
    x = NULL,
    y = "Cores with species (%)"
  ) +
  scale_y_continuous(limits = c(0, 100),
                     expand = expansion(mult = c(0, .05)),
                     labels = function(x) paste0(x, "%")) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.y = element_blank()
  )

# --- Side-by-side with patchwork ---
p1 + p2 + plot_layout(widths = c(2, 1))

```

@fig-BivDensity shows the mean density of each bivalve species across the 60 cores. In total, nine distinct species were identified. The most common was *Scrobicularia plana* (209 individuals per m², on average, present in about 77% of cores), whereas *Ruditapes decussatus* was the least common (0.95 individuals per m²,  present in about 1% of cores).


## Bivalve diversity by core

```{r Shannon index}
#| label: fig-Biv_diversity
#| fig-cap: Interactive lollipop charts of bivalve diversity per core (n = 60). For each core (colored by site), we show Shannon diversity (H′), species richness (S), and Pielou evenness (J′). Metrics were computed from species‐level counts; H′ uses natural logarithms and J′ = H′/ln(S). Lines run from 0 to the core’s value and points mark the estimate; cores with no identified bivalves appear with H′ = 0 and J′ = 0. Hover to see exact values. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"


library(dplyr)
library(tidyr)
library(vegan)
library(ggplot2)
library(ggiraph)
library(scales)
library(tidytext)  # for reorder_within / scale_y_reordered
library(glue)
library(brms)       # Bayesian models via Stan
library(posterior) 

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia","Scrobicularia",Species),
         Species = gsub("derussatus","decussatus", Species))

# --- Core/species universes ---
cores   <- df_bivalve %>% distinct(Core, Site)  # one site per core expected
species <- df_bivalve %>% distinct(Species)

# sanity check: duplicated core->site?
dup_cores <- cores %>% count(Core) %>% filter(n > 1)
if (nrow(dup_cores) > 0) {
  warning("Some cores map to multiple Sites; check 'cores' table.")
}

# --- Long community table with all Core x Species (zeros filled) ---
comm_long <- df_bivalve %>%
  group_by(Core, Species) %>%
  summarise(Abund = sum(Abondance, na.rm = TRUE), .groups = "drop") %>%
  complete(Core = cores$Core, Species = species$Species, fill = list(Abund = 0))

# --- Wide matrix for vegan ---
comm <- comm_long %>%
  pivot_wider(names_from = Species, values_from = Abund, values_fill = 0) %>%
  arrange(Core)

mat <- as.matrix(comm[, -1, drop = FALSE])

# --- Diversity metrics per core ---
H <- vegan::diversity(mat, index = "shannon")      # may be NA for all-zero rows
S <- vegan::specnumber(mat)
J <- ifelse(S > 0, H / log(S), 0)
N <- rowSums(mat)

# replace NA H with 0 for empty cores
H[is.na(H)] <- 0

shannon_by_core <- tibble(
  Core       = comm$Core,
  Shannon_H  = as.numeric(H),
  Richness_S = as.numeric(S),
  Evenness_J = as.numeric(J),
  N_total    = as.integer(N)
) %>%
  left_join(cores, by = "Core")  # safe: 1 row per Core

# --- Long for plotting ---
long <- shannon_by_core %>%
  pivot_longer(c(Shannon_H, Richness_S, Evenness_J),
               names_to = "metric", values_to = "value") %>%
  mutate(
    metric = recode(metric,
      Shannon_H  = "Shannon H′",
      Richness_S = "Richness S",
      Evenness_J = "Evenness J′"
    ),
    tooltip = glue(
      "<b>{Core}</b><br/>Site: {Site}<br/>{metric}: {round(value, 3)}<br/>",
      "Total individuals: {N_total}"
    ),
    Core_ord = reorder_within(Core, value, metric),
    data_id  = paste(Core, metric, sep = "::")   # unique per facet row
  )

# --- Interactive lollipop chart (one row per Core per metric) ---
p <- ggplot(long, aes(x = value, y = Core  , color = Site)) +
  geom_segment_interactive(
    aes(x = 0, xend = value, yend = Core  , tooltip = tooltip, data_id = data_id),
    linewidth = 0.6, alpha = 0.55
  ) +
  geom_point_interactive(
    aes(tooltip = tooltip, data_id = data_id),
    size = 3
  ) +
  facet_wrap(~ metric, scales = "free_x", ncol = 3) +
  scale_y_reordered() +
  labs(title = "Bivalve Diversity by Core (interactive)", x = NULL, y = "Core") +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.major.y = element_blank(),
    legend.position = "top"
  )

girafe(
  ggobj = p,
  width_svg = 10, height_svg = 8,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "multiple", css = "stroke-width:3;"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 4)
  )
)

#### Stats


# # Data we built earlier
# div <- shannon_by_core %>%
#   select(Core, Site, Shannon_H, Richness_S, Evenness_J) %>%
#   mutate(Site = factor(Site, levels = c("L","H")))  # baseline = L
# 
# # For Beta regression (J' in (0,1)), move exact 0/1 slightly inside using Smithson-Verkuilen
# N <- nrow(div)
# div <- div %>%
#   mutate(Evenness_beta = (Evenness_J * (N - 1) + 0.5) / N)
# 
# # ---------- 1) Shannon H′ : Student-t (robust Gaussian) ----------
# fit_H <- brm(
#   Shannon_H ~ 0 + Site,               # group means directly
#   data   = div,
#   family = student(),
#   prior  = c(
#     prior(normal(0, 5), class = "b"),
#     prior(student_t(3, 0, 2.5), class = "sigma"),
#     prior(gamma(2, 0.1), class = "nu")
#   ),
#   chains = 4, iter = 4000, cores = 4, seed = 1
# )
# 
# draws_H <- as_draws_df(fit_H)
# diff_H  <- draws_H$b_SiteH - draws_H$b_SiteL    # posterior of H - L (on original scale)
# 
# # ---------- 2) Richness S : Negative Binomial ----------
# fit_S <- brm(
#   Richness_S ~ 0 + Site,
#   data   = div,
#   family = negbinomial(),              # allows overdispersion
#   prior  = c(
#     prior(normal(0, 2), class = "b"),  # on log mean
#     prior(exponential(1), class = "shape")
#   ),
#   chains = 4, iter = 4000, cores = 4, seed = 2
# )
# 
# # Work on the response scale (expected richness)
# epred_S <- posterior_epred(fit_S, newdata = tibble(Site = factor(c("H","L"), levels = c("L","H"))))
# diff_S  <- epred_S[, 1] - epred_S[, 2]          # H - L (response scale)
# 
# # ---------- 3) Evenness J′ : Beta ----------
# fit_J <- brm(
#   Evenness_beta ~ 0 + Site,
#   data   = div,
#   family = Beta(),
#   prior  = c(
#     prior(normal(0, 1.5), class = "b"),  # on logit(mu)
#     prior(gamma(2, 0.5), class = "phi")
#   ),
#   chains = 4, iter = 4000, cores = 4, seed = 3
# )
# 
# # Expected evenness on response scale
# epred_J <- posterior_epred(fit_J, newdata = tibble(Site = factor(c("H","L"), levels = c("L","H"))))
# diff_J  <- epred_J[, 1] - epred_J[, 2]          # H - L
# 
# # ---------- Summaries (posterior contrasts) ----------
# summ <- function(x, rope = c(NA, NA)) {
#   tibble(
#     mean    = mean(x),
#     median  = median(x),
#     ci_low  = quantile(x, 0.025),
#     ci_high = quantile(x, 0.975),
#     p_gt0   = mean(x > 0),
#     p_lt0   = mean(x < 0),
#     rope_lo = rope[1],
#     rope_hi = rope[2],
#     rope_in = if (any(is.na(rope))) NA_real_ else mean(x > rope[1] & x < rope[2])
#   )
# }
# 
# # Set small ROPEs (adjust to your scientific relevance)
# rope_H <- c(-0.10,  0.10)   # Shannon units
# rope_S <- c(-1.00,  1.00)   # species
# rope_J <- c(-0.05,  0.05)   # evenness units
# 
# results_bayes <- bind_rows(
#   summ(diff_H, rope_H) %>% mutate(metric = "Shannon H′ (H–L)"),
#   summ(diff_S, rope_S) %>% mutate(metric = "Richness S (H–L)"),
#   summ(diff_J, rope_J) %>% mutate(metric = "Evenness J′ (H–L)")
# ) %>% select(metric, everything())
# 
# results_bayes
```

@fig-Biv_diversity shows per-core diversity for the two areas. Each dot is a core (colored by site) and panels display Shannon diversity (H′), species richness (S), and Pielou evenness (J′). Cores from area H generally sit higher for H′ and S, with less separation for J′.

Bayesian comparisons (reported as H–L) back this up.
Shannon diversity is higher in H: mean difference +0.365 with a 95% credible interval \[0.155, 0.579] and $P(H\!-\!L>0)=1.00$. Very little posterior mass falls within a small ±0.10 ROPE, so the increase is not only credible but also practically meaningful.
Richness is also higher in H: +1.23 species on average, 95% CrI \[0.17, 2.31], $P>0=0.988$. About one-third of the posterior lies within a ±1 species ROPE, suggesting a positive but modest gain in the number of species per core.
For evenness, the difference is small and uncertain: +0.116, 95% CrI \[−0.020, 0.247], $P>0=0.956$, with \~15% of the posterior inside a ±0.05 ROPE.

Overall, area H hosts richer and more diverse bivalve assemblages than area L, while evenness is at most slightly higher in H and may be similar between areas.

## Bivalves spatial distribution

```{r bivalves heatmap}
#| echo: false
#| error: false
#| message: false
#| eval: false
#| cache: true
#| warning: false
#| out-width: "95%"

library(terra)
library(tidyverse)
library(readxl)
library(gstat)   # IDW / kriging
library(sf)
library(sp)

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

img <- rast("data/drone/Micasense_Epiphytes_Site_L_cropped.tif")
names(img) <- c(paste0("B",c(1:10)))

mask <- vect("data/shp/mask_Site_L.shp")

for (z in 1:2){

  zone1 <- mask[z]
  
  img_cropped <- img %>% 
    crop(zone1, mask = T) %>% 
    project("EPSG:32630")
  
  df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
    mutate(Station = str_pad(Station, width = 2, pad = "0"),
           Core = paste0(Site,"_",Station),
           Density = Abondance * correction_factor) %>% 
    dplyr::filter(Species != "Inconnu") %>% 
    mutate(Species = gsub("Scobicularia plana","Splana",Species),
           Species = gsub("Ruditapes derussatus","Rdecu", Species),
           Species = gsub("Cerastoderma edule","Cedule", Species),
           Species = gsub("Loripes orbiculatus","Lorbi.", Species),
           Species = gsub("Macoma balthica","Mbalthica", Species),
           Species = gsub("Abra tenuis","Atenuis", Species),
           Species = gsub("Mya arenaria","Marenaria", Species),
            Species = gsub("Mytilus sp,","Mytilus", Species),
           Species = gsub("Ruditapes philippinarum","Rphili", Species)) %>% 
    dplyr::select(Core,Species, Density) %>%
    mutate(Species = gsub(". ","",Species)) %>% 
    pivot_wider(names_from = Species, values_from = Density)
  
  
  sampling_station_zone1 <- sf::read_sf("data/shp/Core_Location/Points.shp") %>% 
    dplyr::select(Name) %>% 
    left_join(df_bivalve, by = c("Name" = "Core")) %>% 
    vect() %>% 
    crop(zone1) %>% 
    project("EPSG:32630")
    
  
  
  clear_rast_1 <- img_cropped$B1
  
  
  species <- names(df_bivalve)[-1]

  
  for(sp in species){
    
    if(sp == "Mbalthica" & z == 2 ){
    }else{
     r_template <- clear_rast_1
    dens_col   <- sp                  # column in the points with species density
    
    # ---- Read & align CRS ----
    pts <- sampling_station_zone1
    # Reproject points to match the raster CRS (important for spatial interpolation)
    if (!identical(crs(pts), crs(r_template))) {
      pts <- project(pts, r_template)
    }
    
    # ---- Basic checks ----
    stopifnot(dens_col %in% names(pts))
    # IDW/kriging should be done in a projected CRS (meters), not lon/lat
    if (grepl("longlat", crs(r_template), ignore.case = TRUE)) {
      warning("Your template raster appears to be in lon/lat. ",
              "Consider projecting it (e.g., to UTM) before interpolating.")
    }
    
    # Keep only points with non-missing density
    pts <- pts[!is.na(pts[[dens_col]]), ]
    
    # ---- Build prediction grid from the template raster ----
    # Get cell-centers for all *non-NA* cells as points (in the same CRS as the raster)
    grid_pts <- as.points(r_template, values = FALSE, na.rm = TRUE)
    
    # Convert to sf for gstat (gstat works natively with sf)
    
    # ---- Convert points to sp (robust for gstat) ----
    pts_sf <- st_as_sf(pts)
    # Drop Z/M if present
    pts_sf <- st_zm(pts_sf, drop = TRUE, what = "ZM")
    
    # Remove duplicated coordinates (kriging requires unique locations)
    coords_mat <- st_coordinates(pts_sf)
    dup_idx <- duplicated(as.data.frame(coords_mat))
    if (any(dup_idx)) {
      # average duplicates
      pts_sf <- pts_sf %>%
        mutate(.x = coords_mat[,1], .y = coords_mat[,2]) %>%
        group_by(.x, .y) %>%
        summarise(!!dens_col := mean(.data[[dens_col]], na.rm = TRUE), .groups = "drop") %>%
        st_as_sf(coords = c(".x", ".y"), crs = st_crs(pts_sf))
    }
    pts_sp <- as(pts_sf, "Spatial")
    
    # ---- Build prediction grid from the raster (only non-NA cells) ----
    vals <- values(r_template)
    ok_cells <- which(!is.na(vals))
    xy <- xyFromCell(r_template, ok_cells)
    grid_sp <- SpatialPixelsDataFrame(points = SpatialPoints(xy, proj4string = CRS(crs(r_template))),
                                      data   = data.frame(id = seq_len(nrow(xy))))
    
    # ---- Empirical variogram + fit ----
   form <- as.formula(paste(dens_col, "~ 1"))
    vg_emp <- variogram(form, data = pts_sp)
    # Try spherical first; fall back if needed
    vg_fit <- try(fit.variogram(vg_emp, model = vgm("Sph")), silent = TRUE)
    if (inherits(vg_fit, "try-error") || any(is.na(vg_fit$psill))) {
      vg_fit <- fit.variogram(vg_emp, model = vgm("Exp"))
    }
    if (any(is.na(vg_fit$psill))) stop("Variogram fit failed. Check data/CRS/duplicates.")
    
    # ---- Ordinary kriging on the grid ----
    ok_sp <- krige(formula = form, locations = pts_sp, newdata = grid_sp, model = vg_fit)
    
    # ---- Write predictions back into the terra raster template ----
    r_ok <- r_template
    pred <- ok_sp$var1.pred
    values(r_ok)[ok_cells] <- pred
    
    # Optional: mask outside convex hull of points to avoid wild extrapolation
    hull_sf <- st_convex_hull(st_union(st_geometry(st_as_sf(pts_sp))))
    r_ok <- mask(r_ok, vect(hull_sf))
    
    # ---- Plot & export ----
    plot(r_ok, main = "Species density — Ordinary Kriging")
    points(pts, pch = 20, cex = 0.6)
    writeRaster(r_ok, paste0("data/heatmap_bivalve_density/density_heatmap_",sp,"_zone_",z,".tif"), overwrite = TRUE)  
    }
  }
} 

mask <- vect("data/shp/mask_Site_L.shp")[1]
mask_32630 <- mask %>% 
  project("EPSG:32630")

heatmap_plana <- rast("data/heatmap_bivalve_density/density_heatmap_Cedule_zone_1.tif")%>% 
  crop(mask_32630, mask = T)
names(heatmap_plana) <- "Cedule"

img <- rast("data/drone/Micasense_Epiphytes_Site_L_cropped.tif") %>% 
  crop(mask, mask = T) %>% 
  project("EPSG:32630")
names(img) <- c(paste0("B",c(1:10)))

NDVI <- (img$B10-img$B6)/(img$B10+img$B6)
names(NDVI) <- "NDVI"

stk <- c(heatmap_plana,NDVI) %>% 
  as.data.frame() %>% 
  dplyr::filter(!is.na(Cedule))

```


# Relationship between bivalves and seagrass biomass

```{r Biv_seagrass}
#| label: fig-Biv_seagrass
#| fig-cap: Density of bivalves in relation with the total biomass of seagrass (sum of above ground and below ground biomass) for site H and L. 
#| echo: false
#| error: false
#| message: false
#| warning: false
#| out-width: "95%"

library(dplyr)
library(tidyr)
library(vegan)
library(ggplot2)
library(ggiraph)
library(scales)
library(tidytext)  # for reorder_within / scale_y_reordered
library(glue)
library(brms)       # Bayesian models via Stan
library(posterior) 

Core_Diameter <- 15
core_area <- pi * ((Core_Diameter/2)^2)
correction_factor <- (100*100)/core_area

df_bivalve <- read_xlsx("data/Abondance_bivalve_Bourgneuf_Bay_REWRITE_2025.xlsx") %>% 
  mutate(Station = str_pad(Station, width = 2, pad = "0"),
         Core = paste0(Site,"_",Station),
         Density = Abondance * correction_factor) %>% 
  dplyr::filter(Species != "Inconnu") %>% 
  mutate(Species = gsub("Scobicularia","Scrobicularia",Species),
         Species = gsub("derussatus","decussatus", Species))

# --- Core/species universes ---
cores   <- df_bivalve %>% distinct(Core, Site)  # one site per core expected
species <- df_bivalve %>% distinct(Species)

# sanity check: duplicated core->site?
dup_cores <- cores %>% count(Core) %>% filter(n > 1)
if (nrow(dup_cores) > 0) {
  warning("Some cores map to multiple Sites; check 'cores' table.")
}

# --- Long community table with all Core x Species (zeros filled) ---
comm_long <- df_bivalve %>%
  group_by(Core, Species) %>%
  summarise(Abund = sum(Abondance, na.rm = TRUE), .groups = "drop") %>%
  complete(Core = cores$Core, Species = species$Species, fill = list(Abund = 0))

# --- Wide matrix for vegan ---
comm <- comm_long %>%
  pivot_wider(names_from = Species, values_from = Abund, values_fill = 0) %>%
  arrange(Core)

mat <- as.matrix(comm[, -1, drop = FALSE])

# --- Diversity metrics per core ---
H <- vegan::diversity(mat, index = "shannon")      # may be NA for all-zero rows
S <- vegan::specnumber(mat)
J <- ifelse(S > 0, H / log(S), 0)
N <- rowSums(mat)

# replace NA H with 0 for empty cores
H[is.na(H)] <- 0

shannon_by_core <- tibble(
  Core       = comm$Core,
  Shannon_H  = as.numeric(H),
  Richness_S = as.numeric(S),
  Evenness_J = as.numeric(J),
  N_total    = as.integer(N)*correction_factor
) %>%
  left_join(cores, by = "Core") 

# --- biomass (convert to g/m²) ---
dryweight <- readxl::read_xlsx("data/DryWeight_Cores.xlsx") %>% 
  mutate(A = A * correction_factor,
         B = B * correction_factor)


df_bivalve_seagrass <- shannon_by_core %>% 
left_join(dryweight, by = c("Core" = "Station")) %>% 
  mutate(overall_biomass = A+B)


# Data for the plot (remove NAs and build tooltips)
plot_df <- df_bivalve_seagrass %>%
  filter(is.finite(A), is.finite(Shannon_H)) %>%
  mutate(
    tooltip = glue(
      "<b>Core:</b> {Core}<br/>",
      "<b>Site:</b> {Site}<br/>",
      "<b>Shannon H′:</b> {round(Shannon_H, 3)}<br/>",
      "<b>Above-ground biomass A:</b> {number(A, accuracy = 0.1)} g/m²<br/>",
      "<b>Below-ground biomass B:</b> {number(B, accuracy = 0.1)} g/m²<br/>",
      "<b>Total biomass:</b> {number(overall_biomass, accuracy = 0.1)} g/m²"
    )
  )

# Plot (points are interactive, smooth shown per site)
p <- ggplot(plot_df, aes(x = overall_biomass, y = N_total , color = Site)) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = Core),
                         size = 3, alpha = 0.9) +
  geom_smooth(method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  # geom_smooth(data = plot_df, mapping = aes(x = A, y = Shannon_H),color = "black",method = "glm", se = TRUE, linewidth = 0.9, alpha = 0.15) +
  labs(
    title = "Bivales per m² vs Seagrass biomass",
    x = "Biomass of seagrass - Above and below - (g/m²)",
    y = "Individuals per m²"
  ) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

g <- girafe(
  ggobj = p,
  width_svg = 9, height_svg = 6,
  options = list(
    opts_hover(css = "stroke-width:2; opacity:1;"),
    opts_selection(type = "single"),
    opts_toolbar(saveaspng = TRUE),
    opts_zoom(max = 5)
  )
)

g
```

@fig-Biv_seagrass shows the relationship between the density of bivalve and the overall biomass (below and above ground) of seagrasses. For a given biomass of seagrass, @fig-Biv_seagrass is showing that the Site H have overall higher density of bivalve then site L. 

```{r zip outputs}
#| echo: false
#| message: false
#| warning: false
#| cache: false
#| eval: true


# ---- settings ----
folder_to_zip <- "data"   # directory whose contents you want to archive
zip_file      <- "Output/Data_REWRITE_Bourgneuf_bay.zip"

# ---- create the zip ----
# list all files (recursive = TRUE grabs sub-folders too; set FALSE if you only
# want the top-level files)
files <- list.files(folder_to_zip, recursive = TRUE, full.names = TRUE)

# make sure you’re in the folder so the archive has relative paths, not full paths

utils::zip(zipfile = zip_file, files = files)
```

